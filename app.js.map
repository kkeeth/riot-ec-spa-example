{"version":3,"file":"app.js","mappings":"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","sources":["webpack://riot-ec-spa-example/./node_modules/@riotjs/dom-bindings/src/constants.js","webpack://riot-ec-spa-example/./node_modules/@riotjs/dom-bindings/src/bindings/each.js","webpack://riot-ec-spa-example/./node_modules/@riotjs/dom-bindings/src/util/create-template-meta.js","webpack://riot-ec-spa-example/./node_modules/@riotjs/dom-bindings/src/util/create-head-tail-placeholders.js","webpack://riot-ec-spa-example/./node_modules/@riotjs/dom-bindings/src/util/udomdiff.js","webpack://riot-ec-spa-example/./node_modules/@riotjs/dom-bindings/src/bindings/if.js","webpack://riot-ec-spa-example/./node_modules/@riotjs/dom-bindings/src/expressions/attribute.js","webpack://riot-ec-spa-example/./node_modules/@riotjs/dom-bindings/src/expressions/event.js","webpack://riot-ec-spa-example/./node_modules/@riotjs/dom-bindings/src/util/normalize-string-value.js","webpack://riot-ec-spa-example/./node_modules/@riotjs/dom-bindings/src/expressions/text.js","webpack://riot-ec-spa-example/./node_modules/@riotjs/dom-bindings/src/expressions/index.js","webpack://riot-ec-spa-example/./node_modules/@riotjs/dom-bindings/src/expressions/value.js","webpack://riot-ec-spa-example/./node_modules/@riotjs/dom-bindings/src/expression.js","webpack://riot-ec-spa-example/./node_modules/@riotjs/dom-bindings/src/bindings/slot.js","webpack://riot-ec-spa-example/./node_modules/@riotjs/dom-bindings/src/bindings/tag.js","webpack://riot-ec-spa-example/./node_modules/@riotjs/dom-bindings/src/bindings/index.js","webpack://riot-ec-spa-example/./node_modules/@riotjs/dom-bindings/src/bindings/simple.js","webpack://riot-ec-spa-example/./node_modules/@riotjs/dom-bindings/src/util/flatten-collection-methods.js","webpack://riot-ec-spa-example/./node_modules/@riotjs/dom-bindings/src/binding.js","webpack://riot-ec-spa-example/./node_modules/@riotjs/dom-bindings/src/template.js","webpack://riot-ec-spa-example/./node_modules/@riotjs/dom-bindings/src/util/create-DOM-tree.js","webpack://riot-ec-spa-example/./node_modules/@riotjs/dom-bindings/src/util/inject-DOM.js","webpack://riot-ec-spa-example/./node_modules/@riotjs/hot-reload/index.js","webpack://riot-ec-spa-example/./node_modules/@riotjs/lazy/index.next.js","webpack://riot-ec-spa-example/./node_modules/@riotjs/route/route.esm.js","webpack://riot-ec-spa-example/./node_modules/@riotjs/util/binding-types.js","webpack://riot-ec-spa-example/./node_modules/@riotjs/util/checks.js","webpack://riot-ec-spa-example/./node_modules/@riotjs/util/constants.js","webpack://riot-ec-spa-example/./node_modules/@riotjs/util/dom.js","webpack://riot-ec-spa-example/./node_modules/@riotjs/util/expression-types.js","webpack://riot-ec-spa-example/./node_modules/@riotjs/util/functions.js","webpack://riot-ec-spa-example/./node_modules/@riotjs/util/misc.js","webpack://riot-ec-spa-example/./node_modules/@riotjs/util/objects.js","webpack://riot-ec-spa-example/./node_modules/@riotjs/util/strings.js","webpack://riot-ec-spa-example/./src/app.riot","webpack://riot-ec-spa-example/./src/components/global/header/my-header.riot","webpack://riot-ec-spa-example/./node_modules/bianco.attr/index.next.js","webpack://riot-ec-spa-example/./node_modules/bianco.dom-to-array/index.next.js","webpack://riot-ec-spa-example/./node_modules/bianco.query/index.next.js","webpack://riot-ec-spa-example/./node_modules/riot/esm/api/__.js","webpack://riot-ec-spa-example/./node_modules/riot/esm/api/component.js","webpack://riot-ec-spa-example/./node_modules/cumpa/index.next.js","webpack://riot-ec-spa-example/./node_modules/riot/esm/api/pure.js","webpack://riot-ec-spa-example/./node_modules/riot/esm/api/register.js","webpack://riot-ec-spa-example/./node_modules/riot/esm/core/pure-component-api.js","webpack://riot-ec-spa-example/./node_modules/riot/esm/core/mocked-template-interface.js","webpack://riot-ec-spa-example/./node_modules/riot/esm/core/bind-dom-node-to-component-instance.js","webpack://riot-ec-spa-example/./node_modules/riot/esm/core/create-core-api-methods.js","webpack://riot-ec-spa-example/./node_modules/riot/esm/core/component-dom-selectors.js","webpack://riot-ec-spa-example/./node_modules/riot/esm/core/component-lifecycle-methods.js","webpack://riot-ec-spa-example/./node_modules/curri/index.next.js","webpack://riot-ec-spa-example/./node_modules/riot/esm/core/compute-component-state.js","webpack://riot-ec-spa-example/./node_modules/riot/esm/core/manage-component-lifecycle.js","webpack://riot-ec-spa-example/./node_modules/riot/esm/core/run-plugins.js","webpack://riot-ec-spa-example/./node_modules/riot/esm/core/create-attribute-bindings.js","webpack://riot-ec-spa-example/./node_modules/riot/esm/core/compute-initial-props.js","webpack://riot-ec-spa-example/./node_modules/riot/esm/core/add-css-hook.js","webpack://riot-ec-spa-example/./node_modules/riot/esm/core/instantiate-component.js","webpack://riot-ec-spa-example/./node_modules/riot/esm/core/create-component-from-wrapper.js","webpack://riot-ec-spa-example/./node_modules/riot/esm/core/component-template-factory.js","webpack://riot-ec-spa-example/./node_modules/riot/esm/core/create-children-components-object.js","webpack://riot-ec-spa-example/./node_modules/riot/esm/core/create-pure-component.js","webpack://riot-ec-spa-example/./node_modules/riot/esm/core/css-manager.js","webpack://riot-ec-spa-example/./node_modules/riot/esm/api/unregister.js","webpack://riot-ec-spa-example/./node_modules/riot/esm/api/mount.js","webpack://riot-ec-spa-example/./node_modules/riot/esm/core/mount-component.js","webpack://riot-ec-spa-example/./node_modules/riot/esm/api/unmount.js","webpack://riot-ec-spa-example/./node_modules/riot/esm/api/install.js","webpack://riot-ec-spa-example/./node_modules/riot/esm/api/uninstall.js","webpack://riot-ec-spa-example/./node_modules/riot/esm/api/with-types.js","webpack://riot-ec-spa-example/./node_modules/riot/esm/api/version.js","webpack://riot-ec-spa-example/./node_modules/riot/esm/utils/dom.js","webpack://riot-ec-spa-example/./src/components/global/ sync [a-zA-Z0-9-]+\\.riot","webpack://riot-ec-spa-example/./src/register-global-components.js","webpack://riot-ec-spa-example/./src/index.js","webpack://riot-ec-spa-example/./src/pages.js","webpack://riot-ec-spa-example/external var \"url\"","webpack://riot-ec-spa-example/webpack/runtime/startup prefetch"],"sourcesContent":["export const HEAD_SYMBOL = Symbol()\nexport const TAIL_SYMBOL = Symbol()\n","import {insertBefore, removeChild} from '@riotjs/util/dom'\nimport createTemplateMeta from '../util/create-template-meta'\nimport {defineProperty} from '@riotjs/util/objects'\nimport {isTemplate} from '@riotjs/util/checks'\nimport udomdiff from '../util/udomdiff'\n\nconst UNMOUNT_SCOPE = Symbol('unmount')\n\nexport const EachBinding = {\n  // dynamic binding properties\n  // childrenMap: null,\n  // node: null,\n  // root: null,\n  // condition: null,\n  // evaluate: null,\n  // template: null,\n  // isTemplateTag: false,\n  nodes: [],\n  // getKey: null,\n  // indexName: null,\n  // itemName: null,\n  // afterPlaceholder: null,\n  // placeholder: null,\n\n  // API methods\n  mount(scope, parentScope) {\n    return this.update(scope, parentScope)\n  },\n  update(scope, parentScope) {\n    const {placeholder, nodes, childrenMap} = this\n    const collection = scope === UNMOUNT_SCOPE ? null : this.evaluate(scope)\n    const items = collection ? Array.from(collection) : []\n\n    // prepare the diffing\n    const {\n      newChildrenMap,\n      batches,\n      futureNodes\n    } = createPatch(items, scope, parentScope, this)\n\n    // patch the DOM only if there are new nodes\n    udomdiff(\n      nodes,\n      futureNodes,\n      patch(\n        Array.from(childrenMap.values()),\n        parentScope\n      ),\n      placeholder\n    )\n\n    // trigger the mounts and the updates\n    batches.forEach(fn => fn())\n\n    // update the children map\n    this.childrenMap = newChildrenMap\n    this.nodes = futureNodes\n\n    return this\n  },\n  unmount(scope, parentScope) {\n    this.update(UNMOUNT_SCOPE, parentScope)\n\n    return this\n  }\n}\n\n/**\n * Patch the DOM while diffing\n * @param   {any[]} redundant - list of all the children (template, nodes, context) added via each\n * @param   {*} parentScope - scope of the parent template\n * @returns {Function} patch function used by domdiff\n */\nfunction patch(redundant, parentScope) {\n  return (item, info) => {\n    if (info < 0) {\n      // get the last element added to the childrenMap saved previously\n      const element = redundant[redundant.length - 1]\n\n      if (element) {\n        // get the nodes and the template in stored in the last child of the childrenMap\n        const {template, nodes, context} = element\n        // remove the last node (notice <template> tags might have more children nodes)\n        nodes.pop()\n\n        // notice that we pass null as last argument because\n        // the root node and its children will be removed by domdiff\n        if (!nodes.length) {\n          // we have cleared all the children nodes and we can unmount this template\n          redundant.pop()\n          template.unmount(context, parentScope, null)\n        }\n      }\n    }\n\n    return item\n  }\n}\n\n/**\n * Check whether a template must be filtered from a loop\n * @param   {Function} condition - filter function\n * @param   {Object} context - argument passed to the filter function\n * @returns {boolean} true if this item should be skipped\n */\nfunction mustFilterItem(condition, context) {\n  return condition ? !condition(context) : false\n}\n\n/**\n * Extend the scope of the looped template\n * @param   {Object} scope - current template scope\n * @param   {Object} options - options\n * @param   {string} options.itemName - key to identify the looped item in the new context\n * @param   {string} options.indexName - key to identify the index of the looped item\n * @param   {number} options.index - current index\n * @param   {*} options.item - collection item looped\n * @returns {Object} enhanced scope object\n */\nfunction extendScope(scope, {itemName, indexName, index, item}) {\n  defineProperty(scope, itemName, item)\n  if (indexName) defineProperty(scope, indexName, index)\n\n  return scope\n}\n\n/**\n * Loop the current template items\n * @param   {Array} items - expression collection value\n * @param   {*} scope - template scope\n * @param   {*} parentScope - scope of the parent template\n * @param   {EachBinding} binding - each binding object instance\n * @returns {Object} data\n * @returns {Map} data.newChildrenMap - a Map containing the new children template structure\n * @returns {Array} data.batches - array containing the template lifecycle functions to trigger\n * @returns {Array} data.futureNodes - array containing the nodes we need to diff\n */\nfunction createPatch(items, scope, parentScope, binding) {\n  const {condition, template, childrenMap, itemName, getKey, indexName, root, isTemplateTag} = binding\n  const newChildrenMap = new Map()\n  const batches = []\n  const futureNodes = []\n\n  items.forEach((item, index) => {\n    const context = extendScope(Object.create(scope), {itemName, indexName, index, item})\n    const key = getKey ? getKey(context) : index\n    const oldItem = childrenMap.get(key)\n    const nodes = []\n\n    if (mustFilterItem(condition, context)) {\n      return\n    }\n\n    const mustMount = !oldItem\n    const componentTemplate = oldItem ? oldItem.template : template.clone()\n    const el = componentTemplate.el || root.cloneNode()\n    const meta = isTemplateTag && mustMount ? createTemplateMeta(componentTemplate) : componentTemplate.meta\n\n    if (mustMount) {\n      batches.push(() => componentTemplate.mount(el, context, parentScope, meta))\n    } else {\n      batches.push(() => componentTemplate.update(context, parentScope))\n    }\n\n    // create the collection of nodes to update or to add\n    // in case of template tags we need to add all its children nodes\n    if (isTemplateTag) {\n      nodes.push(...meta.children)\n    } else {\n      nodes.push(el)\n    }\n\n    // delete the old item from the children map\n    childrenMap.delete(key)\n    futureNodes.push(...nodes)\n\n    // update the children map\n    newChildrenMap.set(key, {\n      nodes,\n      template: componentTemplate,\n      context,\n      index\n    })\n  })\n\n  return {\n    newChildrenMap,\n    batches,\n    futureNodes\n  }\n}\n\nexport default function create(node, {evaluate, condition, itemName, indexName, getKey, template}) {\n  const placeholder = document.createTextNode('')\n  const root = node.cloneNode()\n\n  insertBefore(placeholder,  node)\n  removeChild(node)\n\n  return {\n    ...EachBinding,\n    childrenMap: new Map(),\n    node,\n    root,\n    condition,\n    evaluate,\n    isTemplateTag: isTemplate(root),\n    template: template.createDOM(node),\n    getKey,\n    indexName,\n    itemName,\n    placeholder\n  }\n}\n","import createHeadTailPlaceholders from './create-head-tail-placeholders'\n\n/**\n * Create the template meta object in case of <template> fragments\n * @param   {TemplateChunk} componentTemplate - template chunk object\n * @returns {Object} the meta property that will be passed to the mount function of the TemplateChunk\n */\nexport default function createTemplateMeta(componentTemplate) {\n  const fragment = componentTemplate.dom.cloneNode(true)\n  const {head, tail} = createHeadTailPlaceholders()\n\n  return {\n    avoidDOMInjection: true,\n    fragment,\n    head,\n    tail,\n    children: [head, ...Array.from(fragment.childNodes), tail]\n  }\n}\n","import {HEAD_SYMBOL, TAIL_SYMBOL} from '../constants'\n\n\n/**\n * Create the <template> fragments text nodes\n * @return {Object} {{head: Text, tail: Text}}\n */\nexport default function createHeadTailPlaceholders() {\n  const head = document.createTextNode('')\n  const tail = document.createTextNode('')\n\n  head[HEAD_SYMBOL] = true\n  tail[TAIL_SYMBOL] = true\n\n  return {head, tail}\n}\n","import { insertBefore, removeChild, replaceChild } from '@riotjs/util/dom'\n/**\n * ISC License\n *\n * Copyright (c) 2020, Andrea Giammarchi, @WebReflection\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n// fork of https://github.com/WebReflection/udomdiff version 1.1.0\n// due to https://github.com/WebReflection/udomdiff/pull/2\n/* eslint-disable */\n\n/**\n * @param {Node[]} a The list of current/live children\n * @param {Node[]} b The list of future children\n * @param {(entry: Node, action: number) => Node} get\n * The callback invoked per each entry related DOM operation.\n * @param {Node} [before] The optional node used as anchor to insert before.\n * @returns {Node[]} The same list of future children.\n */\nexport default (a, b, get, before) => {\n  const bLength = b.length;\n  let aEnd = a.length;\n  let bEnd = bLength;\n  let aStart = 0;\n  let bStart = 0;\n  let map = null;\n  while (aStart < aEnd || bStart < bEnd) {\n    // append head, tail, or nodes in between: fast path\n    if (aEnd === aStart) {\n      // we could be in a situation where the rest of nodes that\n      // need to be added are not at the end, and in such case\n      // the node to `insertBefore`, if the index is more than 0\n      // must be retrieved, otherwise it's gonna be the first item.\n      const node = bEnd < bLength ?\n        (bStart ?\n          (get(b[bStart - 1], -0).nextSibling) :\n          get(b[bEnd - bStart], 0)) :\n        before;\n      while (bStart < bEnd)\n        insertBefore(get(b[bStart++], 1), node);\n    }\n    // remove head or tail: fast path\n    else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        // remove the node only if it's unknown or not live\n        if (!map || !map.has(a[aStart]))\n          removeChild(get(a[aStart], -1));\n        aStart++;\n      }\n    }\n    // same node: fast path\n    else if (a[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n    }\n    // same tail: fast path\n    else if (a[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    }\n    // The once here single last swap \"fast path\" has been removed in v1.1.0\n    // https://github.com/WebReflection/udomdiff/blob/single-final-swap/esm/index.js#L69-L85\n    // reverse swap: also fast path\n    else if (\n      a[aStart] === b[bEnd - 1] &&\n      b[bStart] === a[aEnd - 1]\n    ) {\n      // this is a \"shrink\" operation that could happen in these cases:\n      // [1, 2, 3, 4, 5]\n      // [1, 4, 3, 2, 5]\n      // or asymmetric too\n      // [1, 2, 3, 4, 5]\n      // [1, 2, 3, 5, 6, 4]\n      const node = get(a[--aEnd], -1).nextSibling;\n      insertBefore(\n        get(b[bStart++], 1),\n        get(a[aStart++], -1).nextSibling\n      );\n      insertBefore(get(b[--bEnd], 1), node);\n      // mark the future index as identical (yeah, it's dirty, but cheap )\n      // The main reason to do this, is that when a[aEnd] will be reached,\n      // the loop will likely be on the fast path, as identical to b[bEnd].\n      // In the best case scenario, the next loop will skip the tail,\n      // but in the worst one, this node will be considered as already\n      // processed, bailing out pretty quickly from the map index check\n      a[aEnd] = b[bEnd];\n    }\n    // map based fallback, \"slow\" path\n    else {\n      // the map requires an O(bEnd - bStart) operation once\n      // to store all future nodes indexes for later purposes.\n      // In the worst case scenario, this is a full O(N) cost,\n      // and such scenario happens at least when all nodes are different,\n      // but also if both first and last items of the lists are different\n      if (!map) {\n        map = new Map;\n        let i = bStart;\n        while (i < bEnd)\n          map.set(b[i], i++);\n      }\n      // if it's a future node, hence it needs some handling\n      if (map.has(a[aStart])) {\n        // grab the index of such node, 'cause it might have been processed\n        const index = map.get(a[aStart]);\n        // if it's not already processed, look on demand for the next LCS\n        if (bStart < index && index < bEnd) {\n          let i = aStart;\n          // counts the amount of nodes that are the same in the future\n          let sequence = 1;\n          while (++i < aEnd && i < bEnd && map.get(a[i]) === (index + sequence))\n            sequence++;\n          // effort decision here: if the sequence is longer than replaces\n          // needed to reach such sequence, which would brings again this loop\n          // to the fast path, prepend the difference before a sequence,\n          // and move only the future list index forward, so that aStart\n          // and bStart will be aligned again, hence on the fast path.\n          // An example considering aStart and bStart are both 0:\n          // a: [1, 2, 3, 4]\n          // b: [7, 1, 2, 3, 6]\n          // this would place 7 before 1 and, from that time on, 1, 2, and 3\n          // will be processed at zero cost\n          if (sequence > (index - bStart)) {\n            const node = get(a[aStart], 0);\n            while (bStart < index)\n              insertBefore(get(b[bStart++], 1), node);\n          }\n          // if the effort wasn't good enough, fallback to a replace,\n          // moving both source and target indexes forward, hoping that some\n          // similar node will be found later on, to go back to the fast path\n          else {\n            replaceChild(\n              get(b[bStart++], 1),\n              get(a[aStart++], -1)\n            );\n          }\n        }\n        // otherwise move the source forward, 'cause there's nothing to do\n        else\n          aStart++;\n      }\n      // this node has no meaning in the future list, so it's more than safe\n      // to remove it, and check the next live node out instead, meaning\n      // that only the live list index should be forwarded\n      else\n        removeChild(get(a[aStart++], -1));\n    }\n  }\n  return b;\n};\n","import {insertBefore, removeChild} from '@riotjs/util/dom'\n\n/**\n * Binding responsible for the `if` directive\n */\nexport const IfBinding = {\n  // dynamic binding properties\n  // node: null,\n  // evaluate: null,\n  // isTemplateTag: false,\n  // placeholder: null,\n  // template: null,\n\n  // API methods\n  mount(scope, parentScope) {\n    return this.update(scope, parentScope)\n  },\n  update(scope, parentScope) {\n    const value = !!this.evaluate(scope)\n    const mustMount = !this.value && value\n    const mustUnmount = this.value && !value\n    const mount = () => {\n      const pristine = this.node.cloneNode()\n\n      insertBefore(pristine, this.placeholder)\n      this.template = this.template.clone()\n      this.template.mount(pristine, scope, parentScope)\n    }\n\n    switch (true) {\n    case mustMount:\n      mount()\n      break\n    case mustUnmount:\n      this.unmount(scope)\n      break\n    default:\n      if (value) this.template.update(scope, parentScope)\n    }\n\n    this.value = value\n\n    return this\n  },\n  unmount(scope, parentScope) {\n    this.template.unmount(scope, parentScope, true)\n\n    return this\n  }\n}\n\nexport default function create(node, { evaluate, template }) {\n  const placeholder = document.createTextNode('')\n\n  insertBefore(placeholder, node)\n  removeChild(node)\n\n  return {\n    ...IfBinding,\n    node,\n    evaluate,\n    placeholder,\n    template: template.createDOM(node)\n  }\n}\n","import {isBoolean, isFunction, isObject} from '@riotjs/util/checks'\nimport {memoize} from '@riotjs/util/misc'\n\nconst ElementProto = typeof Element === 'undefined' ? {} : Element.prototype\nconst isNativeHtmlProperty = memoize(name => ElementProto.hasOwnProperty(name) ) // eslint-disable-line\n\n/**\n * Add all the attributes provided\n * @param   {HTMLElement} node - target node\n * @param   {Object} attributes - object containing the attributes names and values\n * @returns {undefined} sorry it's a void function :(\n */\nfunction setAllAttributes(node, attributes) {\n  Object\n    .entries(attributes)\n    .forEach(([name, value]) => attributeExpression(node, { name }, value))\n}\n\n/**\n * Remove all the attributes provided\n * @param   {HTMLElement} node - target node\n * @param   {Object} newAttributes - object containing all the new attribute names\n * @param   {Object} oldAttributes - object containing all the old attribute names\n * @returns {undefined} sorry it's a void function :(\n */\nfunction removeAllAttributes(node, newAttributes, oldAttributes) {\n  const newKeys = newAttributes ? Object.keys(newAttributes) : []\n\n  Object\n    .keys(oldAttributes)\n    .filter(name => !newKeys.includes(name))\n    .forEach(attribute => node.removeAttribute(attribute))\n}\n\n/**\n * Check whether the attribute value can be rendered\n * @param {*} value - expression value\n * @returns {boolean} true if we can render this attribute value\n */\nfunction canRenderAttribute(value) {\n  return value === true || ['string', 'number'].includes(typeof value)\n}\n\n/**\n * Check whether the attribute should be removed\n * @param {*} value - expression value\n * @returns {boolean} boolean - true if the attribute can be removed}\n */\nfunction shouldRemoveAttribute(value) {\n  return !value && value !== 0\n}\n\n/**\n * This methods handles the DOM attributes updates\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {string} expression.name - attribute name\n * @param   {*} value - new expression value\n * @param   {*} oldValue - the old expression cached value\n * @returns {undefined}\n */\nexport default function attributeExpression(node, { name }, value, oldValue) {\n  // is it a spread operator? {...attributes}\n  if (!name) {\n    if (oldValue) {\n      // remove all the old attributes\n      removeAllAttributes(node, value, oldValue)\n    }\n\n    // is the value still truthy?\n    if (value) {\n      setAllAttributes(node, value)\n    }\n\n    return\n  }\n\n  // handle boolean attributes\n  if (\n    !isNativeHtmlProperty(name) && (\n      isBoolean(value) ||\n      isObject(value) ||\n      isFunction(value)\n    )\n  ) {\n    node[name] = value\n  }\n\n  if (shouldRemoveAttribute(value)) {\n    node.removeAttribute(name)\n  } else if (canRenderAttribute(value)) {\n    node.setAttribute(name, normalizeValue(name, value))\n  }\n}\n\n/**\n * Get the value as string\n * @param   {string} name - attribute name\n * @param   {*} value - user input value\n * @returns {string} input value as string\n */\nfunction normalizeValue(name, value) {\n  // be sure that expressions like selected={ true } will be always rendered as selected='selected'\n  return (value === true) ? name : value\n}\n","const RE_EVENTS_PREFIX = /^on/\n\nconst getCallbackAndOptions = value => Array.isArray(value) ? value : [value, false]\n\n// see also https://medium.com/@WebReflection/dom-handleevent-a-cross-platform-standard-since-year-2000-5bf17287fd38\nconst EventListener = {\n  handleEvent(event) {\n    this[event.type](event)\n  }\n}\nconst ListenersWeakMap = new WeakMap()\n\nconst createListener = node => {\n  const listener = Object.create(EventListener)\n  ListenersWeakMap.set(node, listener)\n  return listener\n}\n\n/**\n * Set a new event listener\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {string} expression.name - event name\n * @param   {*} value - new expression value\n * @returns {value} the callback just received\n */\nexport default function eventExpression(node, { name }, value) {\n  const normalizedEventName = name.replace(RE_EVENTS_PREFIX, '')\n  const eventListener = ListenersWeakMap.get(node) || createListener(node)\n  const [callback, options] = getCallbackAndOptions(value)\n  const handler = eventListener[normalizedEventName]\n  const mustRemoveEvent = handler && !callback\n  const mustAddEvent = callback && !handler\n\n  if (mustRemoveEvent) {\n    node.removeEventListener(normalizedEventName, eventListener)\n  }\n\n  if (mustAddEvent) {\n    node.addEventListener(normalizedEventName, eventListener, options)\n  }\n\n  eventListener[normalizedEventName] = callback\n}","import {isNil} from '@riotjs/util/checks'\n\n/**\n * Normalize the user value in order to render a empty string in case of falsy values\n * @param   {*} value - user input value\n * @returns {string} hopefully a string\n */\nexport default function normalizeStringValue(value) {\n  return isNil(value) ? '' : value\n}","import normalizeStringValue from '../util/normalize-string-value'\n\n/**\n * Get the the target text node to update or create one from of a comment node\n * @param   {HTMLElement} node - any html element containing childNodes\n * @param   {number} childNodeIndex - index of the text node in the childNodes list\n * @returns {Text} the text node to update\n */\nexport const getTextNode = (node, childNodeIndex) => {\n  const target = node.childNodes[childNodeIndex]\n\n  if (target.nodeType === Node.COMMENT_NODE) {\n    const textNode = document.createTextNode('')\n    node.replaceChild(textNode, target)\n\n    return textNode\n  }\n\n  return target\n}\n\n/**\n * This methods handles a simple text expression update\n * @param   {HTMLElement} node - target node\n * @param   {Object} data - expression object\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\nexport default function textExpression(node, data, value) {\n  node.data = normalizeStringValue(value)\n}\n","import {ATTRIBUTE, EVENT, TEXT, VALUE} from '@riotjs/util/expression-types'\nimport attributeExpression from './attribute'\nimport eventExpression from './event'\nimport textExpression from './text'\nimport valueExpression from './value'\n\nexport default {\n  [ATTRIBUTE]: attributeExpression,\n  [EVENT]: eventExpression,\n  [TEXT]: textExpression,\n  [VALUE]: valueExpression\n}","import normalizeStringValue from '../util/normalize-string-value'\n/**\n * This methods handles the input fileds value updates\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\nexport default function valueExpression(node, expression, value) {\n  node.value = normalizeStringValue(value)\n}","\nimport {EVENT, TEXT} from '@riotjs/util/expression-types'\nimport expressions from './expressions'\nimport {getTextNode} from './expressions/text'\n\nexport const Expression = {\n  // Static props\n  // node: null,\n  // value: null,\n\n  // API methods\n  /**\n   * Mount the expression evaluating its initial value\n   * @param   {*} scope - argument passed to the expression to evaluate its current values\n   * @returns {Expression} self\n   */\n  mount(scope) {\n    // hopefully a pure function\n    this.value = this.evaluate(scope)\n\n    // IO() DOM updates\n    apply(this, this.value)\n\n    return this\n  },\n  /**\n   * Update the expression if its value changed\n   * @param   {*} scope - argument passed to the expression to evaluate its current values\n   * @returns {Expression} self\n   */\n  update(scope) {\n    // pure function\n    const value = this.evaluate(scope)\n\n    if (this.value !== value) {\n      // IO() DOM updates\n      apply(this, value)\n      this.value = value\n    }\n\n    return this\n  },\n  /**\n   * Expression teardown method\n   * @returns {Expression} self\n   */\n  unmount() {\n    // unmount only the event handling expressions\n    if (this.type === EVENT) apply(this, null)\n\n    return this\n  }\n}\n\n/**\n * IO() function to handle the DOM updates\n * @param {Expression} expression - expression object\n * @param {*} value - current expression value\n * @returns {undefined}\n */\nfunction apply(expression, value) {\n  return expressions[expression.type](expression.node, expression, value, expression.value)\n}\n\nexport default function create(node, data) {\n  return {\n    ...Expression,\n    ...data,\n    node: data.type === TEXT ?\n      getTextNode(node, data.childNodeIndex) :\n      node\n  }\n}\n","import {cleanNode, insertBefore, removeChild} from '@riotjs/util/dom'\nimport {PARENT_KEY_SYMBOL} from '@riotjs/util/constants'\nimport {evaluateAttributeExpressions} from '@riotjs/util/misc'\nimport template from '../template'\n\nfunction extendParentScope(attributes, scope, parentScope) {\n  if (!attributes || !attributes.length) return parentScope\n\n  const expressions = attributes.map(attr => ({\n    ...attr,\n    value: attr.evaluate(scope)\n  }))\n\n  return Object.assign(\n    Object.create(parentScope || null),\n    evaluateAttributeExpressions(expressions)\n  )\n}\n\n// this function is only meant to fix an edge case\n// https://github.com/riot/riot/issues/2842\nconst getRealParent = (scope, parentScope) => scope[PARENT_KEY_SYMBOL] || parentScope\n\nexport const SlotBinding = {\n  // dynamic binding properties\n  // node: null,\n  // name: null,\n  attributes: [],\n  // template: null,\n\n  getTemplateScope(scope, parentScope) {\n    return extendParentScope(this.attributes, scope, parentScope)\n  },\n\n  // API methods\n  mount(scope, parentScope) {\n    const templateData = scope.slots ? scope.slots.find(({id}) => id === this.name) : false\n    const {parentNode} = this.node\n    const realParent = getRealParent(scope, parentScope)\n\n    this.template = templateData && template(\n      templateData.html,\n      templateData.bindings\n    ).createDOM(parentNode)\n\n    if (this.template) {\n      cleanNode(this.node)\n      this.template.mount(this.node, this.getTemplateScope(scope, realParent), realParent)\n      this.template.children = Array.from(this.node.childNodes)\n    }\n\n    moveSlotInnerContent(this.node)\n    removeChild(this.node)\n\n    return this\n  },\n  update(scope, parentScope) {\n    if (this.template) {\n      const realParent = getRealParent(scope, parentScope)\n      this.template.update(this.getTemplateScope(scope, realParent), realParent)\n    }\n\n    return this\n  },\n  unmount(scope, parentScope, mustRemoveRoot) {\n    if (this.template) {\n      this.template.unmount(this.getTemplateScope(scope, parentScope), null, mustRemoveRoot)\n    }\n\n    return this\n  }\n}\n\n/**\n * Move the inner content of the slots outside of them\n * @param   {HTMLElement} slot - slot node\n * @returns {undefined} it's a void method \\_()_/\n */\nfunction moveSlotInnerContent(slot) {\n  const child = slot && slot.firstChild\n\n  if (!child) return\n\n  insertBefore(child, slot)\n  moveSlotInnerContent(slot)\n}\n\n/**\n * Create a single slot binding\n * @param   {HTMLElement} node - slot node\n * @param   {string} name - slot id\n * @param   {AttributeExpressionData[]} attributes - slot attributes\n * @returns {Object} Slot binding object\n */\nexport default function createSlot(node, { name, attributes }) {\n  return {\n    ...SlotBinding,\n    attributes,\n    node,\n    name\n  }\n}\n","import {ATTRIBUTE} from '@riotjs/util/expression-types'\nimport template from '../template'\n\n/**\n * Create a new tag object if it was registered before, otherwise fallback to the simple\n * template chunk\n * @param   {Function} component - component factory function\n * @param   {Array<Object>} slots - array containing the slots markup\n * @param   {Array} attributes - dynamic attributes that will be received by the tag element\n * @returns {TagImplementation|TemplateChunk} a tag implementation or a template chunk as fallback\n */\nfunction getTag(component, slots = [], attributes = []) {\n  // if this tag was registered before we will return its implementation\n  if (component) {\n    return component({slots, attributes})\n  }\n\n  // otherwise we return a template chunk\n  return template(slotsToMarkup(slots), [\n    ...slotBindings(slots), {\n      // the attributes should be registered as binding\n      // if we fallback to a normal template chunk\n      expressions: attributes.map(attr => {\n        return {\n          type: ATTRIBUTE,\n          ...attr\n        }\n      })\n    }\n  ])\n}\n\n\n/**\n * Merge all the slots bindings into a single array\n * @param   {Array<Object>} slots - slots collection\n * @returns {Array<Bindings>} flatten bindings array\n */\nfunction slotBindings(slots) {\n  return slots.reduce((acc, {bindings}) => acc.concat(bindings), [])\n}\n\n/**\n * Merge all the slots together in a single markup string\n * @param   {Array<Object>} slots - slots collection\n * @returns {string} markup of all the slots in a single string\n */\nfunction slotsToMarkup(slots) {\n  return slots.reduce((acc, slot) => {\n    return acc + slot.html\n  }, '')\n}\n\n\nexport const TagBinding = {\n  // dynamic binding properties\n  // node: null,\n  // evaluate: null,\n  // name: null,\n  // slots: null,\n  // tag: null,\n  // attributes: null,\n  // getComponent: null,\n\n  mount(scope) {\n    return this.update(scope)\n  },\n  update(scope, parentScope) {\n    const name = this.evaluate(scope)\n\n    // simple update\n    if (name && name === this.name) {\n      this.tag.update(scope)\n    } else {\n      // unmount the old tag if it exists\n      this.unmount(scope, parentScope, true)\n\n      // mount the new tag\n      this.name = name\n      this.tag = getTag(this.getComponent(name), this.slots, this.attributes)\n      this.tag.mount(this.node, scope)\n    }\n\n    return this\n  },\n  unmount(scope, parentScope, keepRootTag) {\n    if (this.tag) {\n      // keep the root tag\n      this.tag.unmount(keepRootTag)\n    }\n\n    return this\n  }\n}\n\nexport default function create(node, {evaluate, getComponent, slots, attributes}) {\n  return {\n    ...TagBinding,\n    node,\n    evaluate,\n    slots,\n    attributes,\n    getComponent\n  }\n}\n","import {EACH, IF, SIMPLE, SLOT, TAG} from '@riotjs/util/binding-types'\nimport EachBinding from './each'\nimport IfBinding from './if'\nimport SimpleBinding from './simple'\nimport SlotBinding from './slot'\nimport TagBinding from './tag'\n\nexport default {\n  [IF]: IfBinding,\n  [SIMPLE]: SimpleBinding,\n  [EACH]: EachBinding,\n  [TAG]: TagBinding,\n  [SLOT]: SlotBinding\n}","import createExpression from '../expression'\nimport flattenCollectionMethods from '../util/flatten-collection-methods'\n\nexport default function create(node, { expressions }) {\n  return {\n    ...flattenCollectionMethods(\n      expressions.map(expression => createExpression(node, expression)),\n      ['mount', 'update', 'unmount']\n    )\n  }\n}\n","/**\n * Create a flat object having as keys a list of methods that if dispatched will propagate\n * on the whole collection\n * @param   {Array} collection - collection to iterate\n * @param   {Array<string>} methods - methods to execute on each item of the collection\n * @param   {*} context - context returned by the new methods created\n * @returns {Object} a new object to simplify the the nested methods dispatching\n */\nexport default function flattenCollectionMethods(collection, methods, context) {\n  return methods.reduce((acc, method) => {\n    return {\n      ...acc,\n      [method]: (scope) => {\n        return collection.map(item => item[method](scope)) && context\n      }\n    }\n  }, {})\n}","import {SIMPLE} from '@riotjs/util/binding-types'\nimport {TEXT} from '@riotjs/util/expression-types'\nimport bindings from './bindings'\n\n/**\n * Text expressions in a template tag will get childNodeIndex value normalized\n * depending on the position of the <template> tag offset\n * @param   {Expression[]} expressions - riot expressions array\n * @param   {number} textExpressionsOffset - offset of the <template> tag\n * @returns {Expression[]} expressions containing the text expressions normalized\n */\nfunction fixTextExpressionsOffset(expressions, textExpressionsOffset) {\n  return expressions.map(e => e.type === TEXT ? {\n    ...e,\n    childNodeIndex: e.childNodeIndex + textExpressionsOffset\n  } : e)\n}\n\n/**\n * Bind a new expression object to a DOM node\n * @param   {HTMLElement} root - DOM node where to bind the expression\n * @param   {TagBindingData} binding - binding data\n * @param   {number|null} templateTagOffset - if it's defined we need to fix the text expressions childNodeIndex offset\n * @returns {Binding} Binding object\n */\nexport default function create(root, binding, templateTagOffset) {\n  const { selector, type, redundantAttribute, expressions } = binding\n  // find the node to apply the bindings\n  const node = selector ? root.querySelector(selector) : root\n\n  // remove eventually additional attributes created only to select this node\n  if (redundantAttribute) node.removeAttribute(redundantAttribute)\n  const bindingExpressions = expressions || []\n\n  // init the binding\n  return (bindings[type] || bindings[SIMPLE])(\n    node,\n    {\n      ...binding,\n      expressions: templateTagOffset && !selector ?\n        fixTextExpressionsOffset(bindingExpressions, templateTagOffset) :\n        bindingExpressions\n    }\n  )\n}\n","import {clearChildren, removeChild} from '@riotjs/util/dom'\nimport {IS_PURE_SYMBOL} from '@riotjs/util/constants'\nimport createBinding from './binding'\nimport createDOMTree from './util/create-DOM-tree'\nimport injectDOM from './util/inject-DOM'\nimport {isTemplate} from '@riotjs/util/checks'\nimport {panic} from '@riotjs/util/misc'\n\n/**\n * Create the Template DOM skeleton\n * @param   {HTMLElement} el - root node where the DOM will be injected\n * @param   {string|HTMLElement} html - HTML markup or HTMLElement that will be injected into the root node\n * @returns {?DocumentFragment} fragment that will be injected into the root node\n */\nfunction createTemplateDOM(el, html) {\n  return html && (typeof html === 'string' ?\n    createDOMTree(el, html) :\n    html)\n}\n\n/**\n * Get the offset of the <template> tag\n * @param {HTMLElement} parentNode - template tag parent node\n * @param {HTMLElement} el - the template tag we want to render\n * @param   {Object} meta - meta properties needed to handle the <template> tags in loops\n * @returns {number} offset of the <template> tag calculated from its siblings DOM nodes\n */\nfunction getTemplateTagOffset(parentNode, el, meta) {\n  const siblings = Array.from(parentNode.childNodes)\n\n  return Math.max(\n    siblings.indexOf(el),\n    siblings.indexOf(meta.head) + 1,\n    0\n  )\n}\n\n/**\n * Template Chunk model\n * @type {Object}\n */\nexport const TemplateChunk = {\n  // Static props\n  // bindings: null,\n  // bindingsData: null,\n  // html: null,\n  // isTemplateTag: false,\n  // fragment: null,\n  // children: null,\n  // dom: null,\n  // el: null,\n\n  /**\n   * Create the template DOM structure that will be cloned on each mount\n   * @param   {HTMLElement} el - the root node\n   * @returns {TemplateChunk} self\n   */\n  createDOM(el) {\n    // make sure that the DOM gets created before cloning the template\n    this.dom = this.dom || createTemplateDOM(el, this.html) || document.createDocumentFragment()\n\n    return this\n  },\n\n  // API methods\n  /**\n   * Attach the template to a DOM node\n   * @param   {HTMLElement} el - target DOM node\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @param   {Object} meta - meta properties needed to handle the <template> tags in loops\n   * @returns {TemplateChunk} self\n   */\n  mount(el, scope, parentScope, meta = {}) {\n    if (!el) panic('Please provide DOM node to mount properly your template')\n\n    if (this.el) this.unmount(scope)\n\n    // <template> tags require a bit more work\n    // the template fragment might be already created via meta outside of this call\n    const {fragment, children, avoidDOMInjection} = meta\n    // <template> bindings of course can not have a root element\n    // so we check the parent node to set the query selector bindings\n    const {parentNode} = children ? children[0] : el\n    const isTemplateTag = isTemplate(el)\n    const templateTagOffset = isTemplateTag ? getTemplateTagOffset(parentNode, el, meta) : null\n\n    // create the DOM if it wasn't created before\n    this.createDOM(el)\n\n    // create the DOM of this template cloning the original DOM structure stored in this instance\n    // notice that if a documentFragment was passed (via meta) we will use it instead\n    const cloneNode = fragment || this.dom.cloneNode(true)\n\n    // store root node\n    // notice that for template tags the root note will be the parent tag\n    this.el = isTemplateTag ? parentNode : el\n\n    // create the children array only for the <template> fragments\n    this.children = isTemplateTag ? children || Array.from(cloneNode.childNodes) : null\n\n    // inject the DOM into the el only if a fragment is available\n    if (!avoidDOMInjection && cloneNode) injectDOM(el, cloneNode)\n\n    // create the bindings\n    this.bindings = this.bindingsData.map(binding => createBinding(\n      this.el,\n      binding,\n      templateTagOffset\n    ))\n    this.bindings.forEach(b => b.mount(scope, parentScope))\n\n    // store the template meta properties\n    this.meta = meta\n\n    return this\n  },\n\n  /**\n   * Update the template with fresh data\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @returns {TemplateChunk} self\n   */\n  update(scope, parentScope) {\n    this.bindings.forEach(b => b.update(scope, parentScope))\n\n    return this\n  },\n\n  /**\n   * Remove the template from the node where it was initially mounted\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @param   {boolean|null} mustRemoveRoot - if true remove the root element,\n   * if false or undefined clean the root tag content, if null don't touch the DOM\n   * @returns {TemplateChunk} self\n   */\n  unmount(scope, parentScope, mustRemoveRoot = false) {\n    const el = this.el\n\n    if (!el) {\n      return this\n    }\n\n    this.bindings.forEach(b => b.unmount(scope, parentScope, mustRemoveRoot))\n\n    switch (true) {\n    // pure components should handle the DOM unmount updates by themselves\n    // for mustRemoveRoot === null don't touch the DOM\n    case (el[IS_PURE_SYMBOL] || mustRemoveRoot === null):\n      break\n\n    // if children are declared, clear them\n    // applicable for <template> and <slot/> bindings\n    case Array.isArray(this.children):\n      clearChildren(this.children)\n      break\n\n    // clean the node children only\n    case !mustRemoveRoot:\n      el.innerHTML = ''\n      break\n\n    // remove the root node only if the mustRemoveRoot is truly\n    case !!mustRemoveRoot:\n      removeChild(el)\n      break\n    }\n\n    this.el = null\n\n    return this\n  },\n\n  /**\n   * Clone the template chunk\n   * @returns {TemplateChunk} a clone of this object resetting the this.el property\n   */\n  clone() {\n    return {\n      ...this,\n      meta: {},\n      el: null\n    }\n  }\n}\n\n\n/**\n * Create a template chunk wiring also the bindings\n * @param   {string|HTMLElement} html - template string\n * @param   {BindingData[]} bindings - bindings collection\n * @returns {TemplateChunk} a new TemplateChunk copy\n */\nexport default function create(html, bindings = []) {\n  return {\n    ...TemplateChunk,\n    html,\n    bindingsData: bindings\n  }\n}\n","import {isSvg, isTemplate} from '@riotjs/util/checks'\n\n// in this case a simple innerHTML is enough\nfunction createHTMLTree(html, root) {\n  const template = isTemplate(root) ? root : document.createElement('template')\n  template.innerHTML = html\n  return template.content\n}\n\n// for svg nodes we need a bit more work\nfunction createSVGTree(html, container) {\n  // create the SVGNode\n  const svgNode = container.ownerDocument.importNode(\n    new window.DOMParser()\n      .parseFromString(\n        `<svg xmlns=\"http://www.w3.org/2000/svg\">${html}</svg>`,\n        'application/xml'\n      )\n      .documentElement,\n    true\n  )\n\n  return svgNode\n}\n\n/**\n * Create the DOM that will be injected\n * @param {Object} root - DOM node to find out the context where the fragment will be created\n * @param   {string} html - DOM to create as string\n * @returns {HTMLDocumentFragment|HTMLElement} a new html fragment\n */\nexport default function createDOMTree(root, html) {\n  if (isSvg(root)) return createSVGTree(html, root)\n\n  return createHTMLTree(html, root)\n}\n\n","import {isSvg, isTemplate} from '@riotjs/util/checks'\nimport {moveChildren} from '@riotjs/util/dom'\n\n/**\n * Inject the DOM tree into a target node\n * @param   {HTMLElement} el - target element\n * @param   {DocumentFragment|SVGElement} dom - dom tree to inject\n * @returns {undefined}\n */\nexport default function injectDOM(el, dom) {\n  switch (true) {\n  case isSvg(el):\n    moveChildren(dom, el)\n    break\n  case isTemplate(el):\n    el.parentNode.replaceChild(dom, el)\n    break\n  default:\n    el.appendChild(dom)\n  }\n}\n","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('riot'), require('bianco.query')) :\n  typeof define === 'function' && define.amd ? define(['exports', 'riot', 'bianco.query'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.riotHotReload = {}, global.riot, global.$));\n})(this, (function (exports, riot, $) { 'use strict';\n\n  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\n  var $__default = /*#__PURE__*/_interopDefaultLegacy($);\n\n  const { cssManager } = riot.__;\n  const { DOM_COMPONENT_INSTANCE_PROPERTY } = riot.__.globals;\n\n  function reload(componentAPI) {\n    const {name} = componentAPI;\n\n    if (!name) {\n      console.warn('Anonymous components can not be reloaded'); // eslint-disable-line\n      return []\n    }\n\n    return $__default[\"default\"](`${name}, [is=${name}]`).map(el => {\n      const oldTag = el[DOM_COMPONENT_INSTANCE_PROPERTY];\n\n      // early return in case there is no riot instance found\n      if (!oldTag) return\n\n      // remove the tag template from the DOM\n      oldTag.unmount(true);\n      // delete the old css from the css manager\n      cssManager.remove(name);\n\n      // create the new tag\n      const newTag = riot.component(componentAPI)(el, oldTag.props);\n      newTag.update(oldTag.state);\n\n      return newTag\n    })\n  }\n\n  exports[\"default\"] = reload;\n  exports.reload = reload;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n","import { component, pure } from 'riot'\nimport { cleanNode } from '@riotjs/util/dom'\n\n// this object will contain all the components implementations lazy loaded\nconst cache = new WeakMap()\n\n// expose the cache as static property\nlazy.cache = cache\n\n// static attribute in case we want to just export a lazy riot component\nlazy.export = function lazyExport(Loader, Component) {\n  // it could be that the user don't want to use a loader for whatever reason\n  const hasLoader = Loader && Component\n  const LazyComponent = hasLoader ? Component : Loader\n  const load = () => typeof LazyComponent === 'function' ? LazyComponent() : Promise.resolve(LazyComponent)\n  const cachedComponent = cache.get(LazyComponent)\n\n  return pure(({ slots, attributes, props }) => ({\n    mount(el, parentScope) {\n      this.el = el\n      this.isMounted = true\n      const mount = () => {\n        this.mountLazyComponent(parentScope)\n        this.el.dispatchEvent(new Event('load'))\n      }\n\n      if (cachedComponent) {\n        mount()\n      } else {\n        if (hasLoader) this.createManagedComponent(Loader, parentScope)\n\n        load().then(data => {\n          cache.set(LazyComponent, data.default || data)\n          mount()\n        })\n      }\n    },\n    createManagedComponent(Child, parentScope) {\n      this.component = component(Child)(this.el, props, {\n        attributes, slots, parentScope\n      })\n    },\n    mountLazyComponent(parentScope) {\n      // if this component was unmounted just return here\n      if (!this.isMounted) return\n\n      // unmount the loader if it was previously created\n      if (this.component) {\n        // unmount the bindings (keeping the root node)\n        this.component.unmount(true)\n        // clean the DOM\n        if (this.el.children.length) cleanNode(this.el)\n      }\n\n      // replace the old component instance with the new lazy loaded component\n      this.createManagedComponent(cache.get(LazyComponent), parentScope)\n    },\n    update(parentScope) {\n      if (this.isMounted && this.component) this.component.update({}, parentScope)\n    },\n    unmount(...args) {\n      this.isMounted = false\n\n      if (this.component) this.component.unmount(...args)\n    }\n  }))\n}\n\nexport default function lazy(Loader, Component) {\n  return {\n    name: 'lazy',\n    exports: lazy.export(Loader, Component)\n  }\n}","import { __, pure } from 'riot';\n\n/**\n * Tokenize input string.\n */\nfunction lexer(str) {\n  var tokens = [];\n  var i = 0;\n\n  while (i < str.length) {\n    var char = str[i];\n\n    if (char === \"*\" || char === \"+\" || char === \"?\") {\n      tokens.push({\n        type: \"MODIFIER\",\n        index: i,\n        value: str[i++]\n      });\n      continue;\n    }\n\n    if (char === \"\\\\\") {\n      tokens.push({\n        type: \"ESCAPED_CHAR\",\n        index: i++,\n        value: str[i++]\n      });\n      continue;\n    }\n\n    if (char === \"{\") {\n      tokens.push({\n        type: \"OPEN\",\n        index: i,\n        value: str[i++]\n      });\n      continue;\n    }\n\n    if (char === \"}\") {\n      tokens.push({\n        type: \"CLOSE\",\n        index: i,\n        value: str[i++]\n      });\n      continue;\n    }\n\n    if (char === \":\") {\n      var name = \"\";\n      var j = i + 1;\n\n      while (j < str.length) {\n        var code = str.charCodeAt(j);\n\n        if ( // `0-9`\n        code >= 48 && code <= 57 || // `A-Z`\n        code >= 65 && code <= 90 || // `a-z`\n        code >= 97 && code <= 122 || // `_`\n        code === 95) {\n          name += str[j++];\n          continue;\n        }\n\n        break;\n      }\n\n      if (!name) throw new TypeError(\"Missing parameter name at \" + i);\n      tokens.push({\n        type: \"NAME\",\n        index: i,\n        value: name\n      });\n      i = j;\n      continue;\n    }\n\n    if (char === \"(\") {\n      var count = 1;\n      var pattern = \"\";\n      var j = i + 1;\n\n      if (str[j] === \"?\") {\n        throw new TypeError(\"Pattern cannot start with \\\"?\\\" at \" + j);\n      }\n\n      while (j < str.length) {\n        if (str[j] === \"\\\\\") {\n          pattern += str[j++] + str[j++];\n          continue;\n        }\n\n        if (str[j] === \")\") {\n          count--;\n\n          if (count === 0) {\n            j++;\n            break;\n          }\n        } else if (str[j] === \"(\") {\n          count++;\n\n          if (str[j + 1] !== \"?\") {\n            throw new TypeError(\"Capturing groups are not allowed at \" + j);\n          }\n        }\n\n        pattern += str[j++];\n      }\n\n      if (count) throw new TypeError(\"Unbalanced pattern at \" + i);\n      if (!pattern) throw new TypeError(\"Missing pattern at \" + i);\n      tokens.push({\n        type: \"PATTERN\",\n        index: i,\n        value: pattern\n      });\n      i = j;\n      continue;\n    }\n\n    tokens.push({\n      type: \"CHAR\",\n      index: i,\n      value: str[i++]\n    });\n  }\n\n  tokens.push({\n    type: \"END\",\n    index: i,\n    value: \"\"\n  });\n  return tokens;\n}\n/**\n * Parse a string for the raw tokens.\n */\n\n\nfunction parse(str, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var tokens = lexer(str);\n  var _a = options.prefixes,\n      prefixes = _a === void 0 ? \"./\" : _a;\n  var defaultPattern = \"[^\" + escapeString(options.delimiter || \"/#?\") + \"]+?\";\n  var result = [];\n  var key = 0;\n  var i = 0;\n  var path = \"\";\n\n  var tryConsume = function tryConsume(type) {\n    if (i < tokens.length && tokens[i].type === type) return tokens[i++].value;\n  };\n\n  var mustConsume = function mustConsume(type) {\n    var value = tryConsume(type);\n    if (value !== undefined) return value;\n    var _a = tokens[i],\n        nextType = _a.type,\n        index = _a.index;\n    throw new TypeError(\"Unexpected \" + nextType + \" at \" + index + \", expected \" + type);\n  };\n\n  var consumeText = function consumeText() {\n    var result = \"\";\n    var value; // tslint:disable-next-line\n\n    while (value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\")) {\n      result += value;\n    }\n\n    return result;\n  };\n\n  while (i < tokens.length) {\n    var char = tryConsume(\"CHAR\");\n    var name = tryConsume(\"NAME\");\n    var pattern = tryConsume(\"PATTERN\");\n\n    if (name || pattern) {\n      var prefix = char || \"\";\n\n      if (prefixes.indexOf(prefix) === -1) {\n        path += prefix;\n        prefix = \"\";\n      }\n\n      if (path) {\n        result.push(path);\n        path = \"\";\n      }\n\n      result.push({\n        name: name || key++,\n        prefix: prefix,\n        suffix: \"\",\n        pattern: pattern || defaultPattern,\n        modifier: tryConsume(\"MODIFIER\") || \"\"\n      });\n      continue;\n    }\n\n    var value = char || tryConsume(\"ESCAPED_CHAR\");\n\n    if (value) {\n      path += value;\n      continue;\n    }\n\n    if (path) {\n      result.push(path);\n      path = \"\";\n    }\n\n    var open = tryConsume(\"OPEN\");\n\n    if (open) {\n      var prefix = consumeText();\n      var name_1 = tryConsume(\"NAME\") || \"\";\n      var pattern_1 = tryConsume(\"PATTERN\") || \"\";\n      var suffix = consumeText();\n      mustConsume(\"CLOSE\");\n      result.push({\n        name: name_1 || (pattern_1 ? key++ : \"\"),\n        pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,\n        prefix: prefix,\n        suffix: suffix,\n        modifier: tryConsume(\"MODIFIER\") || \"\"\n      });\n      continue;\n    }\n\n    mustConsume(\"END\");\n  }\n\n  return result;\n}\n/**\n * Compile a string to a template function for the path.\n */\n\nfunction compile(str, options) {\n  return tokensToFunction(parse(str, options), options);\n}\n/**\n * Expose a method for transforming tokens into the path function.\n */\n\nfunction tokensToFunction(tokens, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var reFlags = flags(options);\n  var _a = options.encode,\n      encode = _a === void 0 ? function (x) {\n    return x;\n  } : _a,\n      _b = options.validate,\n      validate = _b === void 0 ? true : _b; // Compile all the tokens into regexps.\n\n  var matches = tokens.map(function (token) {\n    if (typeof token === \"object\") {\n      return new RegExp(\"^(?:\" + token.pattern + \")$\", reFlags);\n    }\n  });\n  return function (data) {\n    var path = \"\";\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n\n      if (typeof token === \"string\") {\n        path += token;\n        continue;\n      }\n\n      var value = data ? data[token.name] : undefined;\n      var optional = token.modifier === \"?\" || token.modifier === \"*\";\n      var repeat = token.modifier === \"*\" || token.modifier === \"+\";\n\n      if (Array.isArray(value)) {\n        if (!repeat) {\n          throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to not repeat, but got an array\");\n        }\n\n        if (value.length === 0) {\n          if (optional) continue;\n          throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to not be empty\");\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          var segment = encode(value[j], token);\n\n          if (validate && !matches[i].test(segment)) {\n            throw new TypeError(\"Expected all \\\"\" + token.name + \"\\\" to match \\\"\" + token.pattern + \"\\\", but got \\\"\" + segment + \"\\\"\");\n          }\n\n          path += token.prefix + segment + token.suffix;\n        }\n\n        continue;\n      }\n\n      if (typeof value === \"string\" || typeof value === \"number\") {\n        var segment = encode(String(value), token);\n\n        if (validate && !matches[i].test(segment)) {\n          throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to match \\\"\" + token.pattern + \"\\\", but got \\\"\" + segment + \"\\\"\");\n        }\n\n        path += token.prefix + segment + token.suffix;\n        continue;\n      }\n\n      if (optional) continue;\n      var typeOfMessage = repeat ? \"an array\" : \"a string\";\n      throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to be \" + typeOfMessage);\n    }\n\n    return path;\n  };\n}\n/**\n * Escape a regular expression string.\n */\n\nfunction escapeString(str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n/**\n * Get the flags for a regexp from the options.\n */\n\n\nfunction flags(options) {\n  return options && options.sensitive ? \"\" : \"i\";\n}\n/**\n * Pull out keys from a regexp.\n */\n\n\nfunction regexpToRegexp(path, keys) {\n  if (!keys) return path;\n  var groupsRegex = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\n  var index = 0;\n  var execResult = groupsRegex.exec(path.source);\n\n  while (execResult) {\n    keys.push({\n      // Use parenthesized substring match if available, index otherwise\n      name: execResult[1] || index++,\n      prefix: \"\",\n      suffix: \"\",\n      modifier: \"\",\n      pattern: \"\"\n    });\n    execResult = groupsRegex.exec(path.source);\n  }\n\n  return path;\n}\n/**\n * Transform an array into a regexp.\n */\n\n\nfunction arrayToRegexp(paths, keys, options) {\n  var parts = paths.map(function (path) {\n    return pathToRegexp(path, keys, options).source;\n  });\n  return new RegExp(\"(?:\" + parts.join(\"|\") + \")\", flags(options));\n}\n/**\n * Create a path regexp from string input.\n */\n\n\nfunction stringToRegexp(path, keys, options) {\n  return tokensToRegexp(parse(path, options), keys, options);\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\n\n\nfunction tokensToRegexp(tokens, keys, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _a = options.strict,\n      strict = _a === void 0 ? false : _a,\n      _b = options.start,\n      start = _b === void 0 ? true : _b,\n      _c = options.end,\n      end = _c === void 0 ? true : _c,\n      _d = options.encode,\n      encode = _d === void 0 ? function (x) {\n    return x;\n  } : _d;\n  var endsWith = \"[\" + escapeString(options.endsWith || \"\") + \"]|$\";\n  var delimiter = \"[\" + escapeString(options.delimiter || \"/#?\") + \"]\";\n  var route = start ? \"^\" : \"\"; // Iterate over the tokens and create our regexp string.\n\n  for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {\n    var token = tokens_1[_i];\n\n    if (typeof token === \"string\") {\n      route += escapeString(encode(token));\n    } else {\n      var prefix = escapeString(encode(token.prefix));\n      var suffix = escapeString(encode(token.suffix));\n\n      if (token.pattern) {\n        if (keys) keys.push(token);\n\n        if (prefix || suffix) {\n          if (token.modifier === \"+\" || token.modifier === \"*\") {\n            var mod = token.modifier === \"*\" ? \"?\" : \"\";\n            route += \"(?:\" + prefix + \"((?:\" + token.pattern + \")(?:\" + suffix + prefix + \"(?:\" + token.pattern + \"))*)\" + suffix + \")\" + mod;\n          } else {\n            route += \"(?:\" + prefix + \"(\" + token.pattern + \")\" + suffix + \")\" + token.modifier;\n          }\n        } else {\n          route += \"(\" + token.pattern + \")\" + token.modifier;\n        }\n      } else {\n        route += \"(?:\" + prefix + suffix + \")\" + token.modifier;\n      }\n    }\n  }\n\n  if (end) {\n    if (!strict) route += delimiter + \"?\";\n    route += !options.endsWith ? \"$\" : \"(?=\" + endsWith + \")\";\n  } else {\n    var endToken = tokens[tokens.length - 1];\n    var isEndDelimited = typeof endToken === \"string\" ? delimiter.indexOf(endToken[endToken.length - 1]) > -1 : // tslint:disable-next-line\n    endToken === undefined;\n\n    if (!strict) {\n      route += \"(?:\" + delimiter + \"(?=\" + endsWith + \"))?\";\n    }\n\n    if (!isEndDelimited) {\n      route += \"(?=\" + delimiter + \"|\" + endsWith + \")\";\n    }\n  }\n\n  return new RegExp(route, flags(options));\n}\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\n\nfunction pathToRegexp(path, keys, options) {\n  if (path instanceof RegExp) return regexpToRegexp(path, keys);\n  if (Array.isArray(path)) return arrayToRegexp(path, keys, options);\n  return stringToRegexp(path, keys, options);\n}\n\n/**\n * Cancel token\n * @private\n * @type { Symbol }\n */\nconst CANCEL = Symbol();\n/**\n * Helper that can be returned by ruit function to cancel the tasks chain\n * @returns { Symbol } internal private constant\n * @example\n *\n * ruit(\n *   100,\n *   num => Math.random() * num\n *   num => num > 50 ? ruit.cancel() : num\n *   num => num - 2\n * ).then(result => {\n *   console.log(result) // here we will get only number lower than 50\n * })\n *\n */\n\nruit.cancel = () => CANCEL;\n/**\n * The same as ruit() but with the arguments inverted from right to left\n * @param   { * } tasks - list of tasks to process sequentially\n * @returns { Promise } a promise containing the result of the whole chain\n * @example\n *\n * const curry = f => a => b => f(a, b)\n * const add = (a, b) => a + b\n *\n * const addOne = curry(add)(1)\n *\n * const squareAsync = (num) => {\n *   return new Promise(r => {\n *     setTimeout(r, 500, num * 2)\n *   })\n * }\n *\n * // a -> a + a -> a * 2\n * // basically from right to left: 1 => 1 + 1 => 2 * 2\n * ruit.compose(squareAsync, addOne, 1).then(result => console.log(result)) // 4\n */\n\n\nruit.compose = function () {\n  for (var _len = arguments.length, tasks = new Array(_len), _key = 0; _key < _len; _key++) {\n    tasks[_key] = arguments[_key];\n  }\n\n  return ruit(...tasks.reverse());\n};\n/**\n * Serialize a list of sync and async tasks from left to right\n * @param   { * } tasks - list of tasks to process sequentially\n * @returns { Promise } a promise containing the result of the whole chain\n * @example\n *\n * const curry = f => a => b => f(a, b)\n * const add = (a, b) => a + b\n *\n * const addOne = curry(add)(1)\n *\n * const squareAsync = (num) => {\n *   return new Promise(r => {\n *     setTimeout(r, 500, num * 2)\n *   })\n * }\n *\n * // a -> a + a -> a * 2\n * // basically from left to right: 1 => 1 + 1 => 2 * 2\n * ruit(1, addOne, squareAsync).then(result => console.log(result)) // 4\n */\n\n\nfunction ruit() {\n  for (var _len2 = arguments.length, tasks = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    tasks[_key2] = arguments[_key2];\n  }\n\n  return new Promise((resolve, reject) => {\n    return function run(queue, result) {\n      if (!queue.length) return resolve(result);\n      const [task, ...rest] = queue;\n      const value = typeof task === 'function' ? task(result) : task;\n\n      const done = v => run(rest, v); // check against nil values\n\n\n      if (value != null) {\n        if (value === CANCEL) return;\n        if (value.then) return value.then(done, reject);\n      }\n\n      return Promise.resolve(done(value));\n    }(tasks);\n  });\n}\n\nconst API_METHODS = new Set();\nconst UNSUBSCRIBE_SYMBOL = Symbol();\nconst UNSUBSCRIBE_METHOD = 'off';\nconst CANCEL_METHOD = 'cancel';\n/**\n * Factory function to create the stream generator\n * @private\n * @param {Set} modifiers - stream input modifiers\n * @returns {Generator} the stream generator\n */\n\nfunction createStream(modifiers) {\n  const stream = function* stream() {\n    while (true) {\n      // get the initial stream value\n      const input = yield; // run the input sequence\n\n      yield ruit(input, ...modifiers);\n    }\n  }(); // start the stream\n\n\n  stream.next();\n  return stream;\n}\n/**\n * Dispatch a value to several listeners\n * @private\n * @param   {Set} callbacks - callbacks collection\n * @param   {*} value - anything\n * @returns {Set} the callbacks received\n */\n\n\nfunction dispatch(callbacks, value) {\n  callbacks.forEach(f => {\n    // unsubscribe the callback if erre.unsubscribe() will be returned\n    if (f(value) === UNSUBSCRIBE_SYMBOL) callbacks.delete(f);\n  });\n  return callbacks;\n}\n/**\n * Throw a panic error\n * @param {string} message - error message\n * @returns {Error} an error object\n */\n\n\nfunction panic$2(message) {\n  throw new Error(message);\n}\n/**\n * Install an erre plugin adding it to the API\n * @param   {string} name - plugin name\n * @param   {Function} fn - new erre API method\n * @returns {Function} return the erre function\n */\n\n\nerre.install = function (name, fn) {\n  if (!name || typeof name !== 'string') panic$2('Please provide a name (as string) for your erre plugin');\n  if (!fn || typeof fn !== 'function') panic$2('Please provide a function for your erre plugin');\n\n  if (API_METHODS.has(name)) {\n    panic$2(`The ${name} is already part of the erre API, please provide a different name`);\n  } else {\n    erre[name] = fn;\n    API_METHODS.add(name);\n  }\n\n  return erre;\n}; // alias for ruit canel to stop a stream chain\n\n\nerre.install(CANCEL_METHOD, ruit.cancel); // unsubscribe helper\n\nerre.install(UNSUBSCRIBE_METHOD, () => UNSUBSCRIBE_SYMBOL);\n/**\n * Stream constuction function\n * @param   {...Function} fns - stream modifiers\n * @returns {Object} erre instance\n */\n\nfunction erre() {\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n\n  const [success, error, end, modifiers] = [new Set(), new Set(), new Set(), new Set(fns)],\n        generator = createStream(modifiers),\n        stream = Object.create(generator),\n        addToCollection = collection => fn => collection.add(fn) && stream,\n        deleteFromCollection = collection => fn => collection.delete(fn) ? stream : panic$2('Couldn\\'t remove handler passed by reference');\n\n  return Object.assign(stream, {\n    on: Object.freeze({\n      value: addToCollection(success),\n      error: addToCollection(error),\n      end: addToCollection(end)\n    }),\n    off: Object.freeze({\n      value: deleteFromCollection(success),\n      error: deleteFromCollection(error),\n      end: deleteFromCollection(end)\n    }),\n    connect: addToCollection(modifiers),\n\n    push(input) {\n      const {\n        value,\n        done\n      } = stream.next(input); // dispatch the stream events\n\n      if (!done) {\n        value.then(res => dispatch(success, res), err => dispatch(error, err));\n      }\n\n      return stream;\n    },\n\n    end() {\n      // kill the stream\n      generator.return(); // dispatch the end event\n\n      dispatch(end) // clean up all the collections\n      ;\n      [success, error, end, modifiers].forEach(el => el.clear());\n      return stream;\n    },\n\n    fork() {\n      return erre(...modifiers);\n    },\n\n    next(input) {\n      // get the input and run eventually the promise\n      const result = generator.next(input); // pause to the next iteration\n\n      generator.next();\n      return result;\n    }\n\n  });\n}\n\nconst isNode = typeof process !== 'undefined';\n\nconst isString = str => typeof str === 'string'; // the url parsing function depends on the platform, on node we rely on the 'url' module\n\n/* istanbul ignore next */\n\n\nconst parseURL = function parseURL() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return isNode ? require('url').parse(...args) : new URL(...args);\n};\n/**\n * Replace the base path from a path\n * @param   {string} path - router path string\n * @returns {string} path cleaned up without the base\n */\n\n\nconst replaceBase = path => path.replace(defaults.base, '');\n/**\n * Try to match the current path or skip it\n * @param   {RegEx} pathRegExp - target path transformed by pathToRegexp\n * @returns {string|Symbol} if the path match we return it otherwise we cancel the stream\n */\n\n\nconst matchOrSkip = pathRegExp => path => match(path, pathRegExp) ? path : erre.cancel();\n/**\n * Combine 2 streams connecting the events of dispatcherStream to the receiverStream\n * @param   {Stream} dispatcherStream - main stream dispatching events\n * @param   {Stream} receiverStream - sub stream receiving events from the dispatcher\n * @returns {Stream} receiverStream\n */\n\n\nconst joinStreams = (dispatcherStream, receiverStream) => {\n  dispatcherStream.on.value(receiverStream.push);\n  receiverStream.on.end(() => {\n    dispatcherStream.off.value(receiverStream.push);\n  });\n  return receiverStream;\n};\n/**\n * Error handling function\n * @param   {Error} error - error to catch\n * @returns {void}\n */\n\n\nconst panic$1 = error => {\n  if (defaults.silentErrors) return;\n  throw new Error(error);\n}; // make sure that the router will always receive strings params\n\n\nconst filterStrings = str => isString(str) ? str : erre.cancel(); // create the streaming router\n\nconst router = erre(filterStrings).on.error(panic$1); // cast the values of this stream always to string\n\n/* @type {object} general configuration object */\n\nconst defaults = {\n  // custom option\n  base: '',\n  silentErrors: false,\n  // pathToRegexp options\n  sensitive: false,\n  strict: false,\n  end: true,\n  start: true,\n  delimiter: '/#?',\n  encode: undefined,\n  endsWith: undefined,\n  prefixes: './'\n};\n/**\n * Merge the user options with the defaults\n * @param   {Object} options - custom user options\n * @returns {Object} options object merged with defaults\n */\n\nconst mergeOptions = options => Object.assign({}, defaults, options);\n/* {@link https://github.com/pillarjs/path-to-regexp#usage} */\n\nconst toRegexp = (path, keys, options) => pathToRegexp(path, keys, mergeOptions(options));\n/**\n * Convert a router entry to a real path computing the url parameters\n * @param   {string} path - router path string\n * @param   {Object} params - named matched parameters\n * @param   {Object} options - pathToRegexp options object\n * @returns {string} computed url string\n */\n\nconst toPath = (path, params, options) => compile(path, mergeOptions(options))(params);\n/**\n * Parse a string path generating an object containing\n * @param   {string} path - target path\n * @param   {RegExp} pathRegExp - path transformed to regexp via pathToRegexp\n * @param   {Object} options - object containing the base path\n * @returns {URL} url object enhanced with the `match` attribute\n */\n\nconst toURL = function toURL(path, pathRegExp, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  const {\n    base\n  } = mergeOptions(options);\n  const [, ...params] = pathRegExp.exec(path);\n  const url = parseURL(path, base); // extend the url object adding the matched params\n\n  url.params = params.reduce((acc, param, index) => {\n    const key = options.keys && options.keys[index];\n    if (key) acc[key.name] = param ? decodeURIComponent(param) : param;\n    return acc;\n  }, {});\n  return url;\n};\n/**\n * Return true if a path will be matched\n * @param   {string} path - target path\n * @param   {RegExp} pathRegExp - path transformed to regexp via pathToRegexp\n * @returns {boolean} true if the path matches the regexp\n */\n\nconst match = (path, pathRegExp) => pathRegExp.test(path);\n/**\n * Factory function to create an sequence of functions to pass to erre.js\n * This function will be used in the erre stream\n * @param   {RegExp} pathRegExp - path transformed to regexp via pathToRegexp\n * @param   {Object} options - pathToRegexp options object\n * @returns {Array} a functions array that will be used as stream pipe for erre.js\n */\n\nconst createURLStreamPipe = (pathRegExp, options) => [decodeURI, replaceBase, matchOrSkip(pathRegExp), path => toURL(path, pathRegExp, options)];\n/**\n * Create a fork of the main router stream\n * @param   {string} path - route to match\n * @param   {Object} options - pathToRegexp options object\n * @returns {Stream} new route stream\n */\n\nfunction createRoute(path, options) {\n  const keys = [];\n  const pathRegExp = pathToRegexp(path, keys, options);\n  const URLStream = erre(...createURLStreamPipe(pathRegExp, Object.assign({}, options, {\n    keys\n  })));\n  return joinStreams(router, URLStream).on.error(panic$1);\n}\n\nconst getCurrentRoute = (currentRoute => {\n  // listen the route changes events to store the current route\n  router.on.value(r => currentRoute = r);\n  return () => {\n    return currentRoute;\n  };\n})(null);\n\n/**\n * Similar to compose but performs from left-to-right function composition.<br/>\n * {@link https://30secondsofcode.org/function#composeright see also}\n * @param   {...[function]} fns) - list of unary function\n * @returns {*} result of the computation\n */\n/**\n * Performs right-to-left function composition.<br/>\n * Use Array.prototype.reduce() to perform right-to-left function composition.<br/>\n * The last (rightmost) function can accept one or more arguments; the remaining functions must be unary.<br/>\n * {@link https://30secondsofcode.org/function#compose original source code}\n * @param   {...[function]} fns) - list of unary function\n * @returns {*} result of the computation\n */\n\nfunction compose() {\n  for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    fns[_key2] = arguments[_key2];\n  }\n\n  return fns.reduce((f, g) => function () {\n    return f(g(...arguments));\n  });\n}\n\nconst getInitialRouteValue = (pathToRegexp, path, options) => {\n  const route = compose(\n    ...createURLStreamPipe(pathToRegexp, options).reverse()\n  )(path);\n\n  return route.params ? route : null\n};\n\nvar routeHoc = {\n  css: null,\n\n  exports: {\n    onBeforeMount(props) {\n      const currentRoute = getCurrentRoute();\n      const pathToRegexp = toRegexp(props.path, [], props);\n\n      this.state = {\n        pathToRegexp,\n        route: currentRoute && match(currentRoute, pathToRegexp) ?\n          getInitialRouteValue(pathToRegexp, currentRoute, props) :\n          null\n      };\n\n      router.on.value(this.onBeforeRoute);\n      this.stream = createRoute(props.path, props).on.value(this.onRoute);\n    },\n\n    onBeforeRoute(path, pathToRegexp) {\n      if (this.state.route && !match(path, this.state.pathToRegexp)) {\n        this.callLifecycleProperty('onBeforeUnmount', createRoute);\n        this.update({\n          route: null\n        });\n        this.callLifecycleProperty('onUnmounted', createRoute);\n      }\n    },\n\n    onRoute(route) {\n      this.callLifecycleProperty('onBeforeMount', route);\n      this.update({route});\n      this.callLifecycleProperty('onMounted', route);\n    },\n\n    callLifecycleProperty(method, ...params) {\n      if (this.props[method]) this.props[method](...params);\n    },\n\n    onUnmounted() {\n      router.off.value(this.onBeforeRoute);\n      this.stream.end();\n    }\n  },\n\n  template: (\n    template,\n    expressionTypes,\n    bindingTypes,\n    getComponent\n  ) => template(\n    '<template expr0=\"expr0\"></template>',\n    [\n      {\n        type: bindingTypes.IF,\n        evaluate: _scope => _scope.state.route,\n        redundantAttribute: 'expr0',\n        selector: '[expr0]',\n\n        template: template(\n          '<slot expr1=\"expr1\"></slot>',\n          [\n            {\n              type: bindingTypes.SLOT,\n\n              attributes: [\n                {\n                  type: expressionTypes.ATTRIBUTE,\n                  name: 'route',\n                  evaluate: _scope => _scope.state.route\n                }\n              ],\n\n              name: 'default',\n              redundantAttribute: 'expr1',\n              selector: '[expr1]'\n            }\n          ]\n        )\n      }\n    ]\n  ),\n\n  name: 'route-hoc'\n};\n\nconst getGlobal = () => getWindow() || global;\nconst getWindow = () => typeof window === 'undefined' ? null : window;\nconst getDocument = () => typeof document === 'undefined' ? null : document;\nconst getHistory = () => typeof history === 'undefined' ? null : history;\nconst getLocation = () => {\n  const win = getWindow();\n  return win ? win.location : {};\n};\nconst defer = (() => {\n  const globalScope = getGlobal();\n  return globalScope.requestAnimationFrame || globalScope.setTimeout;\n})();\nconst cancelDefer = (() => {\n  const globalScope = getGlobal();\n  return globalScope.cancelAnimationFrame || globalScope.clearTimeout;\n})();\n\nconst WINDOW_EVENTS = 'popstate';\nconst CLICK_EVENT = 'click';\nconst DOWNLOAD_LINK_ATTRIBUTE = 'download';\nconst HREF_LINK_ATTRIBUTE = 'href';\nconst TARGET_SELF_LINK_ATTRIBUTE = '_self';\nconst LINK_TAG_NAME = 'A';\nconst HASH = '#';\nconst SLASH = '/';\nconst RE_ORIGIN = /^.+?\\/\\/+[^/]+/;\n\nconst normalizeInitialSlash = str => str[0] === SLASH ? str : `${SLASH}${str}`;\nconst removeTrailingSlash = str => str[str.length - 1] === SLASH ? str.substr(0, str.length - 1) : str;\nconst normalizeBase = base => {\n  const win = getWindow();\n  const loc = win.location;\n  const root = loc ? `${loc.protocol}//${loc.host}` : '';\n  const {\n    pathname\n  } = loc ? loc : {};\n\n  switch (true) {\n    // pure root url + pathname\n    case Boolean(base) === false:\n      return removeTrailingSlash(`${root}${pathname || ''}`);\n    // full path base\n\n    case /(www|http(s)?:)/.test(base):\n      return base;\n    // hash navigation\n\n    case base[0] === HASH:\n      return `${root}${pathname && pathname !== SLASH ? pathname : ''}${base}`;\n    // root url with trailing slash\n\n    case base === SLASH:\n      return removeTrailingSlash(root);\n    // custom pathname\n\n    default:\n      return removeTrailingSlash(`${root}${normalizeInitialSlash(base)}`);\n  }\n};\nfunction setBase(base) {\n  defaults.base = normalizeBase(base);\n}\n\n/**\n * Convert a string from camel case to dash-case\n * @param   {string} string - probably a component tag name\n * @returns {string} component name normalized\n */\n/**\n * Convert a string containing dashes to camel case\n * @param   {string} string - input string\n * @returns {string} my-string -> myString\n */\n\nfunction dashToCamelCase(string) {\n  return string.replace(/-(\\w)/g, (_, c) => c.toUpperCase());\n}\n\n/**\n * Throw an error with a descriptive message\n * @param   { string } message - error message\n * @returns { undefined } hoppla.. at this point the program should stop working\n */\n\nfunction panic(message) {\n  throw new Error(message);\n}\n\n/**\n * Converts any DOM node/s to a loopable array\n * @param   { HTMLElement|NodeList } els - single html element or a node list\n * @returns { Array } always a loopable object\n */\nfunction domToArray(els) {\n  // can this object be already looped?\n  if (!Array.isArray(els)) {\n    // is it a node list?\n    if (/^\\[object (HTMLCollection|NodeList|Object)\\]$/.test(Object.prototype.toString.call(els)) && typeof els.length === 'number') return Array.from(els);else // if it's a single node\n      // it will be returned as \"array\" with one single entry\n      return [els];\n  } // this object could be looped out of the box\n\n\n  return els;\n}\n\n/**\n * Split a string into several items separed by spaces\n * @param   { string } l - events list\n * @returns { Array } all the events detected\n * @private\n */\n\nconst split = l => l.split(/\\s/);\n/**\n * Set a listener for all the events received separated by spaces\n * @param   { HTMLElement|NodeList|Array } els     - DOM node/s where the listeners will be bound\n * @param   { string }                     evList  - list of events we want to bind or unbind space separated\n * @param   { Function }                   cb      - listeners callback\n * @param   { string }                     method  - either 'addEventListener' or 'removeEventListener'\n * @param   { Object }                     options - event options (capture, once and passive)\n * @returns { undefined }\n * @private\n */\n\n\nfunction manageEvents(els, evList, cb, method, options) {\n  els = domToArray(els);\n  split(evList).forEach(e => {\n    els.forEach(el => el[method](e, cb, options || false));\n  });\n}\n/**\n * Set a listener for all the events received separated by spaces\n * @param   { HTMLElement|Array } els    - DOM node/s where the listeners will be bound\n * @param   { string }            evList - list of events we want to bind space separated\n * @param   { Function }          cb     - listeners callback\n * @param   { Object }            options - event options (capture, once and passive)\n * @returns { HTMLElement|NodeList|Array } DOM node/s and first argument of the function\n */\n\n\nfunction add(els, evList, cb, options) {\n  manageEvents(els, evList, cb, 'addEventListener', options);\n  return els;\n}\n/**\n * Remove all the listeners for the events received separated by spaces\n * @param   { HTMLElement|Array } els     - DOM node/s where the events will be unbind\n * @param   { string }            evList  - list of events we want unbind space separated\n * @param   { Function }          cb      - listeners callback\n * @param   { Object }             options - event options (capture, once and passive)\n * @returns { HTMLElement|NodeList|Array }  DOM node/s and first argument of the function\n */\n\nfunction remove(els, evList, cb, options) {\n  manageEvents(els, evList, cb, 'removeEventListener', options);\n  return els;\n}\n\n/**\n * Normalize the return values, in case of a single value we avoid to return an array\n * @param   { Array } values - list of values we want to return\n * @returns { Array|string|boolean } either the whole list of values or the single one found\n * @private\n */\n\nconst normalize = values => values.length === 1 ? values[0] : values;\n/**\n * Parse all the nodes received to get/remove/check their attributes\n * @param   { HTMLElement|NodeList|Array } els    - DOM node/s to parse\n * @param   { string|Array }               name   - name or list of attributes\n * @param   { string }                     method - method that will be used to parse the attributes\n * @returns { Array|string } result of the parsing in a list or a single value\n * @private\n */\n\n\nfunction parseNodes(els, name, method) {\n  const names = typeof name === 'string' ? [name] : name;\n  return normalize(domToArray(els).map(el => {\n    return normalize(names.map(n => el[method](n)));\n  }));\n}\n/**\n * Set any attribute on a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Array }               name  - name or list of attributes to detect\n * @returns { boolean|Array } true or false or an array of boolean values\n * @example\n *\n * import { has } from 'bianco.attr'\n *\n * has(img, 'width') // false\n *\n * // or also\n * has(img, ['width', 'height']) // => [false, false]\n *\n * // or also\n * has([img1, img2], ['width', 'height']) // => [[false, false], [false, false]]\n */\n\nfunction has(els, name) {\n  return parseNodes(els, name, 'hasAttribute');\n}\n\nconst onWindowEvent = () => router.push(normalizePath(String(getLocation().href)));\n\nconst onRouterPush = path => {\n  const url = path.includes(defaults.base) ? path : defaults.base + path;\n  const loc = getLocation();\n  const hist = getHistory();\n  const doc = getDocument(); // update the browser history only if it's necessary\n\n  if (hist && url !== loc.href) {\n    hist.pushState(null, doc.title, url);\n  }\n};\n\nconst getLinkElement = node => node && !isLinkNode(node) ? getLinkElement(node.parentNode) : node;\n\nconst isLinkNode = node => node.nodeName === LINK_TAG_NAME;\n\nconst isCrossOriginLink = path => path.indexOf(getLocation().href.match(RE_ORIGIN)[0]) === -1;\n\nconst isTargetSelfLink = el => el.target && el.target !== TARGET_SELF_LINK_ATTRIBUTE;\n\nconst isEventForbidden = event => event.which && event.which !== 1 // not left click\n|| event.metaKey || event.ctrlKey || event.shiftKey // or meta keys\n|| event.defaultPrevented; // or default prevented\n\n\nconst isForbiddenLink = el => !el || !isLinkNode(el) // not A tag\n|| has(el, DOWNLOAD_LINK_ATTRIBUTE) // has download attr\n|| !has(el, HREF_LINK_ATTRIBUTE) // has no href attr\n|| isTargetSelfLink(el) || isCrossOriginLink(el.href);\n\nconst isHashLink = path => path.split(HASH).length > 1;\n\nconst normalizePath = path => path.replace(defaults.base, '');\n\nconst isInBase = path => !defaults.base || path.includes(defaults.base);\n/**\n * Callback called anytime something will be clicked on the page\n * @param   {HTMLEvent} event - click event\n * @returns {undefined} void method\n */\n\n\nconst onClick = event => {\n  if (isEventForbidden(event)) return;\n  const el = getLinkElement(event.target);\n  if (isForbiddenLink(el) || isHashLink(el.href) || !isInBase(el.href)) return;\n  const path = normalizePath(el.href);\n  router.push(path);\n  event.preventDefault();\n};\n/**\n * Link the rawth router to the DOM events\n * @param { HTMLElement } container - DOM node where the links are located\n * @returns {Function} teardown function\n */\n\n\nfunction initDomListeners(container) {\n  const win = getWindow();\n  const root = container || getDocument();\n\n  if (win) {\n    add(win, WINDOW_EVENTS, onWindowEvent);\n    add(root, CLICK_EVENT, onClick);\n  }\n\n  router.on.value(onRouterPush);\n  return () => {\n    if (win) {\n      remove(win, WINDOW_EVENTS, onWindowEvent);\n      remove(root, CLICK_EVENT, onClick);\n    }\n\n    router.off.value(onRouterPush);\n  };\n}\n\nconst BASE_ATTRIBUTE_NAME = 'base';\nconst INITIAL_ROUTE = 'initialRoute';\nconst ON_STARTED_ATTRIBUTE_NAME = 'onStarted';\nconst {template, bindingTypes} = __.DOMBindings;\n\n\nlet wasInitialized = false;\n\nvar routerHoc = {\n  css: null,\n\n  exports: pure(\n    ({slots, attributes, props}) => {\n      if (wasInitialized) panic('Multiple <router> components are not supported');\n\n      const getAttribute = name => attributes && attributes.find(a => dashToCamelCase(a.name) === name);\n\n      return {\n        slot: null,\n        el: null,\n        teardown: null,\n        mount(el, context) {\n          const initialRouteAttr = getAttribute(INITIAL_ROUTE);\n          const initialRoute = initialRouteAttr ? initialRouteAttr.evaluate(context) : null;\n          const currentRoute =  getCurrentRoute();\n          const onFirstRoute = () => {\n            this.createSlot(context);\n            router.off.value(onFirstRoute);\n          };\n          wasInitialized = true;\n\n          this.el = el;\n          this.teardown = initDomListeners(this.root);\n\n          this.setBase(context);\n\n          // mount the slots only if the current route was defined\n          if (currentRoute && !initialRoute) {\n            this.createSlot(context);\n          } else {\n            router.on.value(onFirstRoute);\n            router.push(initialRoute || window.location.href);\n          }\n        },\n        createSlot(context) {\n          if (!slots || !slots.length) return\n          const onStartedAttr = getAttribute(ON_STARTED_ATTRIBUTE_NAME);\n\n          this.slot = template(null, [{\n            type: bindingTypes.SLOT,\n            name: 'default'\n          }]);\n\n          this.slot.mount(this.el, {\n            slots\n          }, context);\n\n          if (onStartedAttr) {\n            onStartedAttr.evaluate(context)(getCurrentRoute());\n          }\n        },\n        update(context) {\n          this.setBase(context);\n\n          // defer the updates to avoid internal recursive update calls\n          // see https://github.com/riot/route/issues/148\n          if (this.slot) {\n            cancelDefer(this.deferred);\n\n            this.deferred = defer(() => {\n              this.slot.update({}, context);\n            });\n          }\n        },\n        unmount(...args) {\n          this.teardown();\n          wasInitialized = false;\n\n          if (this.slot) {\n            this.slot.unmount(...args);\n          }\n        },\n        getBase(context) {\n          const baseAttr = getAttribute(BASE_ATTRIBUTE_NAME);\n\n          return baseAttr ? this.el.getAttribute(BASE_ATTRIBUTE_NAME) || baseAttr.evaluate(context) : '/'\n        },\n        setBase(context) {\n          setBase(props ? props.base : this.getBase(context));\n        }\n      }\n    }\n  ),\n\n  template: null,\n  name: 'router-hoc'\n};\n\nexport { routeHoc as Route, routerHoc as Router, createURLStreamPipe, filterStrings, getCurrentRoute, initDomListeners, match, createRoute as route, router, setBase, toPath, toRegexp, toURL };\n","export const EACH = 0\nexport const IF = 1\nexport const SIMPLE = 2\nexport const TAG = 3\nexport const SLOT = 4\n\nexport default {\n  EACH,\n  IF,\n  SIMPLE,\n  TAG,\n  SLOT\n}","/**\n * Quick type checking\n * @param   {*} element - anything\n * @param   {string} type - type definition\n * @returns {boolean} true if the type corresponds\n */\nexport function checkType(element, type) {\n  return typeof element === type\n}\n\n/**\n * Check if an element is part of an svg\n * @param   {HTMLElement}  el - element to check\n * @returns {boolean} true if we are in an svg context\n */\nexport function isSvg(el) {\n  const owner = el.ownerSVGElement\n\n  return !!owner || owner === null\n}\n\n/**\n * Check if an element is a template tag\n * @param   {HTMLElement}  el - element to check\n * @returns {boolean} true if it's a <template>\n */\nexport function isTemplate(el) {\n  return el.tagName.toLowerCase() === 'template'\n}\n\n/**\n * Check that will be passed if its argument is a function\n * @param   {*} value - value to check\n * @returns {boolean} - true if the value is a function\n */\nexport function isFunction(value) {\n  return checkType(value, 'function')\n}\n\n/**\n * Check if a value is a Boolean\n * @param   {*}  value - anything\n * @returns {boolean} true only for the value is a boolean\n */\nexport function isBoolean(value) {\n  return checkType(value, 'boolean')\n}\n\n/**\n * Check if a value is an Object\n * @param   {*}  value - anything\n * @returns {boolean} true only for the value is an object\n */\nexport function isObject(value) {\n  return !isNil(value) && value.constructor === Object\n}\n\n/**\n * Check if a value is null or undefined\n * @param   {*}  value - anything\n * @returns {boolean} true only for the 'undefined' and 'null' types\n */\nexport function isNil(value) {\n  return value === null || value === undefined\n}\n\n/**\n * Detect node js environements\n * @returns {boolean} true if the runtime is node\n */\nexport function isNode() {\n  return typeof process !== 'undefined'\n}\n","// Riot.js constants that can be used accross more modules\n\nexport const\n  COMPONENTS_IMPLEMENTATION_MAP = new Map(),\n  DOM_COMPONENT_INSTANCE_PROPERTY = Symbol('riot-component'),\n  PLUGINS_SET = new Set(),\n  IS_DIRECTIVE = 'is',\n  VALUE_ATTRIBUTE = 'value',\n  MOUNT_METHOD_KEY = 'mount',\n  UPDATE_METHOD_KEY = 'update',\n  UNMOUNT_METHOD_KEY = 'unmount',\n  SHOULD_UPDATE_KEY = 'shouldUpdate',\n  ON_BEFORE_MOUNT_KEY = 'onBeforeMount',\n  ON_MOUNTED_KEY = 'onMounted',\n  ON_BEFORE_UPDATE_KEY = 'onBeforeUpdate',\n  ON_UPDATED_KEY = 'onUpdated',\n  ON_BEFORE_UNMOUNT_KEY = 'onBeforeUnmount',\n  ON_UNMOUNTED_KEY = 'onUnmounted',\n  PROPS_KEY = 'props',\n  STATE_KEY = 'state',\n  SLOTS_KEY = 'slots',\n  ROOT_KEY = 'root',\n  IS_PURE_SYMBOL = Symbol('pure'),\n  IS_COMPONENT_UPDATING = Symbol('is_updating'),\n  PARENT_KEY_SYMBOL = Symbol('parent'),\n  ATTRIBUTES_KEY_SYMBOL = Symbol('attributes'),\n  TEMPLATE_KEY_SYMBOL = Symbol('template')\n","import {dashToCamelCase} from './strings'\n\n/**\n * Get all the element attributes as object\n * @param   {HTMLElement} element - DOM node we want to parse\n * @returns {Object} all the attributes found as a key value pairs\n */\nexport function DOMattributesToObject(element) {\n  return Array.from(element.attributes).reduce((acc, attribute) => {\n    acc[dashToCamelCase(attribute.name)] = attribute.value\n    return acc\n  }, {})\n}\n\n/**\n * Move all the child nodes from a source tag to another\n * @param   {HTMLElement} source - source node\n * @param   {HTMLElement} target - target node\n * @returns {undefined} it's a void method \\_()_/\n */\n\n// Ignore this helper because it's needed only for svg tags\nexport function moveChildren(source, target) {\n  if (source.firstChild) {\n    target.appendChild(source.firstChild)\n    moveChildren(source, target)\n  }\n}\n\n/**\n * Remove the child nodes from any DOM node\n * @param   {HTMLElement} node - target node\n * @returns {undefined}\n */\nexport function cleanNode(node) {\n  clearChildren(node.childNodes)\n}\n\n/**\n * Clear multiple children in a node\n * @param   {HTMLElement[]} children - direct children nodes\n * @returns {undefined}\n */\nexport function clearChildren(children) {\n  Array.from(children).forEach(removeChild)\n}\n\n\n/**\n * Remove a node\n * @param {HTMLElement}node - node to remove\n * @returns {undefined}\n */\nexport const removeChild = node => node && node.parentNode && node.parentNode.removeChild(node)\n\n/**\n * Insert before a node\n * @param {HTMLElement} newNode - node to insert\n * @param {HTMLElement} refNode - ref child\n * @returns {undefined}\n */\nexport const insertBefore = (newNode, refNode) => refNode && refNode.parentNode && refNode.parentNode.insertBefore(newNode, refNode)\n\n/**\n * Replace a node\n * @param {HTMLElement} newNode - new node to add to the DOM\n * @param {HTMLElement} replaced - node to replace\n * @returns {undefined}\n */\nexport const replaceChild = (newNode, replaced) => replaced && replaced.parentNode && replaced.parentNode.replaceChild(newNode, replaced)\n","export const ATTRIBUTE = 0\nexport const EVENT = 1\nexport const TEXT = 2\nexport const VALUE = 3\n\nexport default {\n  ATTRIBUTE,\n  EVENT,\n  TEXT,\n  VALUE\n}","import {isFunction} from './checks'\n\n// does simply nothing\nexport function noop() {\n  return this\n}\n\n/**\n * Autobind the methods of a source object to itself\n * @param   {Object} source - probably a riot tag instance\n * @param   {Array<string>} methods - list of the methods to autobind\n * @returns {Object} the original object received\n */\nexport function autobindMethods(source, methods) {\n  methods.forEach(method => {\n    source[method] = source[method].bind(source)\n  })\n\n  return source\n}\n\n/**\n * Call the first argument received only if it's a function otherwise return it as it is\n * @param   {*} source - anything\n * @returns {*} anything\n */\nexport function callOrAssign(source) {\n  return isFunction(source) ? (source.prototype && source.prototype.constructor ?\n    new source() : source()\n  ) : source\n}\n","import {ATTRIBUTE, VALUE} from './expression-types'\nimport {dashToCamelCase} from './strings'\n\n/**\n * Throw an error with a descriptive message\n * @param   { string } message - error message\n * @returns { undefined } hoppla.. at this point the program should stop working\n */\nexport function panic(message) {\n  throw new Error(message)\n}\n/**\n * Returns the memoized (cached) function.\n * // borrowed from https://www.30secondsofcode.org/js/s/memoize\n * @param {Function} fn - function to memoize\n * @returns {Function} memoize function\n */\nexport function memoize(fn) {\n  const cache = new Map()\n  const cached = val => {\n    return cache.has(val) ? cache.get(val) : cache.set(val, fn.call(this, val)) && cache.get(val)\n  }\n  cached.cache = cache\n  return cached\n}\n\n/**\n * Evaluate a list of attribute expressions\n * @param   {Array} attributes - attribute expressions generated by the riot compiler\n * @returns {Object} key value pairs with the result of the computation\n */\nexport function evaluateAttributeExpressions(attributes) {\n  return attributes.reduce((acc, attribute) => {\n    const {value, type} = attribute\n\n    switch (true) {\n    // spread attribute\n    case !attribute.name && type === ATTRIBUTE:\n      return {\n        ...acc,\n        ...value\n      }\n    // value attribute\n    case type === VALUE:\n      acc.value = attribute.value\n      break\n    // normal attributes\n    default:\n      acc[dashToCamelCase(attribute.name)] = attribute.value\n    }\n\n    return acc\n  }, {})\n}","\n/**\n * Helper function to set an immutable property\n * @param   {Object} source - object where the new property will be set\n * @param   {string} key - object key where the new property will be stored\n * @param   {*} value - value of the new property\n * @param   {Object} options - set the propery overriding the default options\n * @returns {Object} - the original object modified\n */\nexport function defineProperty(source, key, value, options = {}) {\n  /* eslint-disable fp/no-mutating-methods */\n  Object.defineProperty(source, key, {\n    value,\n    enumerable: false,\n    writable: false,\n    configurable: true,\n    ...options\n  })\n  /* eslint-enable fp/no-mutating-methods */\n\n  return source\n}\n\n/**\n * Define multiple properties on a target object\n * @param   {Object} source - object where the new properties will be set\n * @param   {Object} properties - object containing as key pair the key + value properties\n * @param   {Object} options - set the propery overriding the default options\n * @returns {Object} the original object modified\n */\nexport function defineProperties(source, properties, options) {\n  Object.entries(properties).forEach(([key, value]) => {\n    defineProperty(source, key, value, options)\n  })\n\n  return source\n}\n\n/**\n * Define default properties if they don't exist on the source object\n * @param   {Object} source - object that will receive the default properties\n * @param   {Object} defaults - object containing additional optional keys\n * @returns {Object} the original object received enhanced\n */\nexport function defineDefaults(source, defaults) {\n  Object.entries(defaults).forEach(([key, value]) => {\n    if (!source[key]) source[key] = value\n  })\n\n  return source\n}\n\n/**\n * Simple clone deep function, do not use it for classes or recursive objects!\n * @param   {*} source - possibily an object to clone\n * @returns {*} the object we wanted to clone\n */\nexport function cloneDeep(source) {\n  return JSON.parse(JSON.stringify(source))\n}\n","/**\n * Convert a string from camel case to dash-case\n * @param   {string} string - probably a component tag name\n * @returns {string} component name normalized\n */\nexport function camelToDashCase(string) {\n  return string.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase()\n}\n\n/**\n * Convert a string containing dashes to camel case\n * @param   {string} string - input string\n * @returns {string} my-string -> myString\n */\nexport function dashToCamelCase(string) {\n  return string.replace(/-(\\w)/g, (_, c) => c.toUpperCase())\n}","<app>\n  <div class=\"container\">\n    <my-header />\n    <router>\n      <div class=\"row\">\n        <nav class=\"menu column\">\n          <a\n            each={page in state.pages}\n            class={state.activePage === page ? 'active' : '' }\n            href={page.path}>\n            {page.label}\n          </a>\n        </nav>\n      </div>\n      <div if={state.showNotFound} class=\"row\">\n        <div class=\"column column-60\">\n          <not-found />\n        </div>\n      </div>\n      <div if={!state.showNotFound} class=\"row\">\n        <div class=\"column column-60\">\n          <route each={page in state.pages} path={page.path}>\n            <main is={page.componentName} initial-props={page.initialProps} />\n          </route>\n        </div>\n      </div>\n    </router>\n    <my-footer />\n  </div>\n\n  <script>\n    import { Router, Route, route, toRegexp, match } from '@riotjs/route'\n    import lazy from '@riotjs/lazy'\n    import Loader from './components/includes/loader/loader.riot'\n    import NotFound from './pages/not-found.riot'\n    import pages from './pages'\n    import MyHeader from './components/global/header/my-header.riot'\n    import MyFooter from './components/global/footer/my-footer.riot'\n\n    export default {\n      components: {\n        Router,\n        Route,\n        NotFound,\n        MyHeader,\n        MyFooter,\n        Home: lazy(Loader, () => import(\n          /* webpackPrefetch: true, webpackChunkName: 'pages/home' */\n          './pages/home.riot'\n        )),\n        About: lazy(Loader, () => import(\n          /* webpackPrefetch: true, webpackChunkName: 'pages/about' */\n          './pages/about.riot'\n        )),\n      },\n      state: {\n        pages,\n        showNotFound: false,\n        activePage: null\n      },\n      onBeforeMount({ isServer }) {\n        // create a stream on all routes to catch the not-found page\n        this.anyRouteStream = route('(.*)')\n        this.anyRouteStream.on.value(this.onAnyRoute)\n      },\n      onAnyRoute(path) {\n        // show the not found page if none of the page paths are matched\n        const activePage = pages.find(p => match(path.pathname, toRegexp(p.path)))\n\n        this.update({\n          activePage,\n          showNotFound: !activePage\n        })\n      },\n      onBeforeUnmount() {\n        this.anyRouteStream.end()\n      }\n    }\n  </script>\n\n  <style>\n    :host {\n      padding: 2rem 0;\n    }\n\n    .menu {\n      margin: 1rem -1rem;\n    }\n\n    .menu a {\n      padding: 0 1rem;\n      color: black;\n    }\n\n    .menu a.active.active {\n      font-weight: bold;\n      color: #008080;\n      text-decoration: none;\n    }\n\n    .menu a:hover, .menu a:focus, .menu a:active {\n      text-decoration: underline;\n    }\n  </style>\n</app>\n","<my-header>\n  <header>\n    <a href=\"/\">\n      <img src=\"/static/logo.svg\" alt=\"\" >\n    </a>\n    <a href=\"/\">\n      <h1 >FishCastle</h1>\n    </a>\n    <a href=\"#\" style={{textDecoration: \"none\"}}>\n    <svg width=\"31\" height=\"27\" viewBox=\"0 0 31 27\" fill=\"none\" xmlns=\"<http://www.w3.org/2000/svg>\">\n      <path d=\"\" fill=\"#9094FF\"/>\n    </svg>\n    <span></span>\n    </a>\n  </header>\n</my-header>","import domToArray from 'bianco.dom-to-array'\n\n/**\n * Normalize the return values, in case of a single value we avoid to return an array\n * @param   { Array } values - list of values we want to return\n * @returns { Array|string|boolean } either the whole list of values or the single one found\n * @private\n */\nconst normalize = values => values.length === 1 ? values[0] : values\n\n/**\n * Parse all the nodes received to get/remove/check their attributes\n * @param   { HTMLElement|NodeList|Array } els    - DOM node/s to parse\n * @param   { string|Array }               name   - name or list of attributes\n * @param   { string }                     method - method that will be used to parse the attributes\n * @returns { Array|string } result of the parsing in a list or a single value\n * @private\n */\nfunction parseNodes(els, name, method) {\n  const names = typeof name === 'string' ? [name] : name\n  return normalize(domToArray(els).map(el => {\n    return normalize(names.map(n => el[method](n)))\n  }))\n}\n\n/**\n * Set any attribute on a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Object }              name  - either the name of the attribute to set\n *                                                 or a list of properties as object key - value\n * @param   { string }                     value - the new value of the attribute (optional)\n * @returns { HTMLElement|NodeList|Array } the original array of elements passed to this function\n *\n * @example\n *\n * import { set } from 'bianco.attr'\n *\n * const img = document.createElement('img')\n *\n * set(img, 'width', 100)\n *\n * // or also\n * set(img, {\n *   width: 300,\n *   height: 300\n * })\n *\n */\nexport function set(els, name, value) {\n  const attrs = typeof name === 'object' ? name : { [name]: value }\n  const props = Object.keys(attrs)\n\n  domToArray(els).forEach(el => {\n    props.forEach(prop => el.setAttribute(prop, attrs[prop]))\n  })\n  return els\n}\n\n/**\n * Get any attribute from a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Array }               name  - name or list of attributes to get\n * @returns { Array|string } list of the attributes found\n *\n * @example\n *\n * import { get } from 'bianco.attr'\n *\n * const img = document.createElement('img')\n *\n * get(img, 'width') // => '200'\n *\n * // or also\n * get(img, ['width', 'height']) // => ['200', '300']\n *\n * // or also\n * get([img1, img2], ['width', 'height']) // => [['200', '300'], ['500', '200']]\n */\nexport function get(els, name) {\n  return parseNodes(els, name, 'getAttribute')\n}\n\n/**\n * Remove any attribute from a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Array }               name  - name or list of attributes to remove\n * @returns { HTMLElement|NodeList|Array } the original array of elements passed to this function\n *\n * @example\n *\n * import { remove } from 'bianco.attr'\n *\n * remove(img, 'width') // remove the width attribute\n *\n * // or also\n * remove(img, ['width', 'height']) // remove the width and the height attribute\n *\n * // or also\n * remove([img1, img2], ['width', 'height']) // remove the width and the height attribute from both images\n */\nexport function remove(els, name) {\n  return parseNodes(els, name, 'removeAttribute')\n}\n\n/**\n * Set any attribute on a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Array }               name  - name or list of attributes to detect\n * @returns { boolean|Array } true or false or an array of boolean values\n * @example\n *\n * import { has } from 'bianco.attr'\n *\n * has(img, 'width') // false\n *\n * // or also\n * has(img, ['width', 'height']) // => [false, false]\n *\n * // or also\n * has([img1, img2], ['width', 'height']) // => [[false, false], [false, false]]\n */\nexport function has(els, name) {\n  return parseNodes(els, name, 'hasAttribute')\n}\n\nexport default {\n  get,\n  set,\n  remove,\n  has\n}","/**\n * Converts any DOM node/s to a loopable array\n * @param   { HTMLElement|NodeList } els - single html element or a node list\n * @returns { Array } always a loopable object\n */\nexport default function domToArray(els) {\n  // can this object be already looped?\n  if (!Array.isArray(els)) {\n    // is it a node list?\n    if (\n      /^\\[object (HTMLCollection|NodeList|Object)\\]$/\n        .test(Object.prototype.toString.call(els))\n        && typeof els.length === 'number'\n    )\n      return Array.from(els)\n    else\n      // if it's a single node\n      // it will be returned as \"array\" with one single entry\n      return [els]\n  }\n  // this object could be looped out of the box\n  return els\n}","import domToArray from 'bianco.dom-to-array'\n\n/**\n * Simple helper to find DOM nodes returning them as array like loopable object\n * @param   { string|DOMNodeList } selector - either the query or the DOM nodes to arraify\n * @param   { HTMLElement }        scope      - context defining where the query will search for the DOM nodes\n * @returns { Array } DOM nodes found as array\n */\nexport default function $(selector, scope) {\n  return domToArray(typeof selector === 'string' ?\n    (scope || document).querySelectorAll(selector) :\n    selector\n  )\n}\n","/* Riot WIP, @license MIT */\nimport { template, createBinding, createExpression, bindingTypes, expressionTypes } from '@riotjs/dom-bindings';\nimport { DOM_COMPONENT_INSTANCE_PROPERTY, PARENT_KEY_SYMBOL } from '@riotjs/util';\nimport cssManager from '../core/css-manager.js';\n\nconst __ = {\n  cssManager,\n  DOMBindings: {\n    template,\n    createBinding,\n    createExpression,\n    bindingTypes,\n    expressionTypes\n  },\n  globals: {\n    DOM_COMPONENT_INSTANCE_PROPERTY,\n    PARENT_KEY_SYMBOL\n  }\n};\n\nexport { __ };\n","/* Riot WIP, @license MIT */\nimport compose from 'cumpa';\nimport { createComponentFromWrapper } from '../core/create-component-from-wrapper.js';\n\n/**\n * Helper method to create component without relying on the registered ones\n * @param   {Object} implementation - component implementation\n * @returns {Function} function that will allow you to mount a riot component on a DOM node\n */\n\nfunction component(implementation) {\n  return function (el, props, _temp) {\n    let {\n      slots,\n      attributes,\n      parentScope\n    } = _temp === void 0 ? {} : _temp;\n    return compose(c => c.mount(el, parentScope), c => c({\n      props,\n      slots,\n      attributes\n    }), createComponentFromWrapper)(implementation);\n  };\n}\n\nexport { component };\n","/**\n * Similar to compose but performs from left-to-right function composition.<br/>\n * {@link https://30secondsofcode.org/function#composeright see also}\n * @param   {...[function]} fns) - list of unary function\n * @returns {*} result of the computation\n */\nexport const composeRight = (...fns) => compose(...fns.reverse())\n\n/**\n * Performs right-to-left function composition.<br/>\n * Use Array.prototype.reduce() to perform right-to-left function composition.<br/>\n * The last (rightmost) function can accept one or more arguments; the remaining functions must be unary.<br/>\n * {@link https://30secondsofcode.org/function#compose original source code}\n * @param   {...[function]} fns) - list of unary function\n * @returns {*} result of the computation\n */\nexport default function compose(...fns) {\n  return fns.reduce((f, g) => (...args) => f(g(...args)))\n}","/* Riot WIP, @license MIT */\nimport { isFunction, panic, IS_PURE_SYMBOL } from '@riotjs/util';\n\n/**\n * Lift a riot component Interface into a pure riot object\n * @param   {Function} func - RiotPureComponent factory function\n * @returns {Function} the lifted original function received as argument\n */\n\nfunction pure(func) {\n  if (!isFunction(func)) panic('riot.pure accepts only arguments of type \"function\"');\n  func[IS_PURE_SYMBOL] = true;\n  return func;\n}\n\nexport { pure };\n","/* Riot WIP, @license MIT */\nimport { COMPONENTS_IMPLEMENTATION_MAP, panic } from '@riotjs/util';\nimport { createComponentFromWrapper } from '../core/create-component-from-wrapper.js';\n\n/**\n * Register a custom tag by name\n * @param   {string} name - component name\n * @param   {Object} implementation - tag implementation\n * @returns {Map} map containing all the components implementations\n */\n\nfunction register(name, _ref) {\n  let {\n    css,\n    template,\n    exports\n  } = _ref;\n  if (COMPONENTS_IMPLEMENTATION_MAP.has(name)) panic(`The component \"${name}\" was already registered`);\n  COMPONENTS_IMPLEMENTATION_MAP.set(name, createComponentFromWrapper({\n    name,\n    css,\n    template,\n    exports\n  }));\n  return COMPONENTS_IMPLEMENTATION_MAP;\n}\n\nexport { register };\n","/* Riot WIP, @license MIT */\nimport { MOUNT_METHOD_KEY, noop, UPDATE_METHOD_KEY, UNMOUNT_METHOD_KEY } from '@riotjs/util';\n\nconst PURE_COMPONENT_API = Object.freeze({\n  [MOUNT_METHOD_KEY]: noop,\n  [UPDATE_METHOD_KEY]: noop,\n  [UNMOUNT_METHOD_KEY]: noop\n});\n\nexport { PURE_COMPONENT_API };\n","/* Riot WIP, @license MIT */\nimport { PURE_COMPONENT_API } from './pure-component-api.js';\nimport { noop } from '@riotjs/util';\n\nconst MOCKED_TEMPLATE_INTERFACE = Object.assign({}, PURE_COMPONENT_API, {\n  clone: noop,\n  createDOM: noop\n});\n\nexport { MOCKED_TEMPLATE_INTERFACE };\n","/* Riot WIP, @license MIT */\nimport { DOM_COMPONENT_INSTANCE_PROPERTY } from '@riotjs/util';\n\n/**\n * Bind a DOM node to its component object\n * @param   {HTMLElement} node - html node mounted\n * @param   {Object} component - Riot.js component object\n * @returns {Object} the component object received as second argument\n */\n\nconst bindDOMNodeToComponentInstance = (node, component) => node[DOM_COMPONENT_INSTANCE_PROPERTY] = component;\n\nexport { bindDOMNodeToComponentInstance };\n","/* Riot WIP, @license MIT */\nimport { MOUNT_METHOD_KEY, UPDATE_METHOD_KEY, UNMOUNT_METHOD_KEY } from '@riotjs/util';\n\n/**\n * Wrap the Riot.js core API methods using a mapping function\n * @param   {Function} mapFunction - lifting function\n * @returns {Object} an object having the { mount, update, unmount } functions\n */\n\nfunction createCoreAPIMethods(mapFunction) {\n  return [MOUNT_METHOD_KEY, UPDATE_METHOD_KEY, UNMOUNT_METHOD_KEY].reduce((acc, method) => {\n    acc[method] = mapFunction(method);\n    return acc;\n  }, {});\n}\n\nexport { createCoreAPIMethods };\n","/* Riot WIP, @license MIT */\nimport $ from 'bianco.query';\n\nconst COMPONENT_DOM_SELECTORS = Object.freeze({\n  // component helpers\n  $(selector) {\n    return $(selector, this.root)[0];\n  },\n\n  $$(selector) {\n    return $(selector, this.root);\n  }\n\n});\n\nexport { COMPONENT_DOM_SELECTORS };\n","/* Riot WIP, @license MIT */\nimport { SHOULD_UPDATE_KEY, noop, ON_BEFORE_MOUNT_KEY, ON_MOUNTED_KEY, ON_BEFORE_UPDATE_KEY, ON_UPDATED_KEY, ON_BEFORE_UNMOUNT_KEY, ON_UNMOUNTED_KEY } from '@riotjs/util';\n\nconst COMPONENT_LIFECYCLE_METHODS = Object.freeze({\n  [SHOULD_UPDATE_KEY]: noop,\n  [ON_BEFORE_MOUNT_KEY]: noop,\n  [ON_MOUNTED_KEY]: noop,\n  [ON_BEFORE_UPDATE_KEY]: noop,\n  [ON_UPDATED_KEY]: noop,\n  [ON_BEFORE_UNMOUNT_KEY]: noop,\n  [ON_UNMOUNTED_KEY]: noop\n});\n\nexport { COMPONENT_LIFECYCLE_METHODS };\n","/**\n * Function to curry any javascript method\n * @param   {Function}  fn - the target function we want to curry\n * @param   {...[args]} acc - initial arguments\n * @returns {Function|*} it will return a function until the target function\n *                       will receive all of its arguments\n */\nexport default function curry(fn, ...acc) {\n  return (...args) => {\n    args = [...acc, ...args]\n\n    return args.length < fn.length ?\n      curry(fn, ...args) :\n      fn(...args)\n  }\n}","/* Riot WIP, @license MIT */\nimport { callOrAssign } from '@riotjs/util';\n\n/**\n * Compute the component current state merging it with its previous state\n * @param   {Object} oldState - previous state object\n * @param   {Object} newState - new state given to the `update` call\n * @returns {Object} new object state\n */\n\nfunction computeComponentState(oldState, newState) {\n  return Object.assign({}, oldState, callOrAssign(newState));\n}\n\nexport { computeComponentState };\n","/* Riot WIP, @license MIT */\nimport { autobindMethods, defineProperties, isObject, defineProperty, IS_PURE_SYMBOL, PARENT_KEY_SYMBOL, ATTRIBUTES_KEY_SYMBOL, PROPS_KEY, evaluateAttributeExpressions, STATE_KEY, TEMPLATE_KEY_SYMBOL, ROOT_KEY, SLOTS_KEY, ON_BEFORE_MOUNT_KEY, ON_MOUNTED_KEY, SHOULD_UPDATE_KEY, ON_BEFORE_UPDATE_KEY, IS_COMPONENT_UPDATING, ON_UPDATED_KEY, ON_BEFORE_UNMOUNT_KEY, ON_UNMOUNTED_KEY, isFunction } from '@riotjs/util';\nimport { addCssHook } from './add-css-hook.js';\nimport { bindDOMNodeToComponentInstance } from './bind-dom-node-to-component-instance.js';\nimport { computeComponentState } from './compute-component-state.js';\nimport { computeInitialProps } from './compute-initial-props.js';\nimport { createAttributeBindings } from './create-attribute-bindings.js';\nimport { runPlugins } from './run-plugins.js';\n\n/**\n * Component creation factory function that will enhance the user provided API\n * @param   {Object} component - a component implementation previously defined\n * @param   {Array} options.slots - component slots generated via riot compiler\n * @param   {Array} options.attributes - attribute expressions generated via riot compiler\n * @returns {Riot.Component} a riot component instance\n */\n\nfunction manageComponentLifecycle(component, _ref) {\n  let {\n    slots,\n    attributes,\n    props\n  } = _ref;\n  return autobindMethods(runPlugins(defineProperties(isObject(component) ? Object.create(component) : component, {\n    mount(element, state, parentScope) {\n      if (state === void 0) {\n        state = {};\n      }\n\n      // any element mounted passing through this function can't be a pure component\n      defineProperty(element, IS_PURE_SYMBOL, false);\n      this[PARENT_KEY_SYMBOL] = parentScope;\n      this[ATTRIBUTES_KEY_SYMBOL] = createAttributeBindings(element, attributes).mount(parentScope);\n      defineProperty(this, PROPS_KEY, Object.freeze(Object.assign({}, computeInitialProps(element, props), evaluateAttributeExpressions(this[ATTRIBUTES_KEY_SYMBOL].expressions))));\n      this[STATE_KEY] = computeComponentState(this[STATE_KEY], state);\n      this[TEMPLATE_KEY_SYMBOL] = this.template.createDOM(element).clone(); // link this object to the DOM node\n\n      bindDOMNodeToComponentInstance(element, this); // add eventually the 'is' attribute\n\n      component.name && addCssHook(element, component.name); // define the root element\n\n      defineProperty(this, ROOT_KEY, element); // define the slots array\n\n      defineProperty(this, SLOTS_KEY, slots); // before mount lifecycle event\n\n      this[ON_BEFORE_MOUNT_KEY](this[PROPS_KEY], this[STATE_KEY]); // mount the template\n\n      this[TEMPLATE_KEY_SYMBOL].mount(element, this, parentScope);\n      this[ON_MOUNTED_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      return this;\n    },\n\n    update(state, parentScope) {\n      if (state === void 0) {\n        state = {};\n      }\n\n      if (parentScope) {\n        this[PARENT_KEY_SYMBOL] = parentScope;\n        this[ATTRIBUTES_KEY_SYMBOL].update(parentScope);\n      }\n\n      const newProps = evaluateAttributeExpressions(this[ATTRIBUTES_KEY_SYMBOL].expressions);\n      if (this[SHOULD_UPDATE_KEY](newProps, this[PROPS_KEY]) === false) return;\n      defineProperty(this, PROPS_KEY, Object.freeze(Object.assign({}, this[PROPS_KEY], newProps)));\n      this[STATE_KEY] = computeComponentState(this[STATE_KEY], state);\n      this[ON_BEFORE_UPDATE_KEY](this[PROPS_KEY], this[STATE_KEY]); // avoiding recursive updates\n      // see also https://github.com/riot/riot/issues/2895\n\n      if (!this[IS_COMPONENT_UPDATING]) {\n        this[IS_COMPONENT_UPDATING] = true;\n        this[TEMPLATE_KEY_SYMBOL].update(this, this[PARENT_KEY_SYMBOL]);\n      }\n\n      this[ON_UPDATED_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      this[IS_COMPONENT_UPDATING] = false;\n      return this;\n    },\n\n    unmount(preserveRoot) {\n      this[ON_BEFORE_UNMOUNT_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      this[ATTRIBUTES_KEY_SYMBOL].unmount(); // if the preserveRoot is null the template html will be left untouched\n      // in that case the DOM cleanup will happen differently from a parent node\n\n      this[TEMPLATE_KEY_SYMBOL].unmount(this, this[PARENT_KEY_SYMBOL], preserveRoot === null ? null : !preserveRoot);\n      this[ON_UNMOUNTED_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      return this;\n    }\n\n  })), Object.keys(component).filter(prop => isFunction(component[prop])));\n}\n\nexport { manageComponentLifecycle };\n","/* Riot WIP, @license MIT */\nimport { PLUGINS_SET } from '@riotjs/util';\n\n/**\n * Run the component instance through all the plugins set by the user\n * @param   {Object} component - component instance\n * @returns {Object} the component enhanced by the plugins\n */\n\nfunction runPlugins(component) {\n  return [...PLUGINS_SET].reduce((c, fn) => fn(c) || c, component);\n}\n\nexport { runPlugins };\n","/* Riot WIP, @license MIT */\nimport { createCoreAPIMethods } from './create-core-api-methods.js';\nimport { createExpression } from '@riotjs/dom-bindings';\n\n/**\n * Create the bindings to update the component attributes\n * @param   {HTMLElement} node - node where we will bind the expressions\n * @param   {Array} attributes - list of attribute bindings\n * @returns {TemplateChunk} - template bindings object\n */\n\nfunction createAttributeBindings(node, attributes) {\n  if (attributes === void 0) {\n    attributes = [];\n  }\n\n  const expressions = attributes.map(a => createExpression(node, a));\n  const binding = {};\n  return Object.assign(binding, Object.assign({\n    expressions\n  }, createCoreAPIMethods(method => scope => {\n    expressions.forEach(e => e[method](scope));\n    return binding;\n  })));\n}\n\nexport { createAttributeBindings };\n","/* Riot WIP, @license MIT */\nimport { DOMattributesToObject, callOrAssign } from '@riotjs/util';\n\n/**\n * Evaluate the component properties either from its real attributes or from its initial user properties\n * @param   {HTMLElement} element - component root\n * @param   {Object}  initialProps - initial props\n * @returns {Object} component props key value pairs\n */\n\nfunction computeInitialProps(element, initialProps) {\n  if (initialProps === void 0) {\n    initialProps = {};\n  }\n\n  return Object.assign({}, DOMattributesToObject(element), callOrAssign(initialProps));\n}\n\nexport { computeInitialProps };\n","/* Riot WIP, @license MIT */\nimport { IS_DIRECTIVE } from '@riotjs/util';\nimport { getName } from '../utils/dom.js';\nimport { set } from 'bianco.attr';\n\n/**\n * Add eventually the \"is\" attribute to link this DOM node to its css\n * @param {HTMLElement} element - target root node\n * @param {string} name - name of the component mounted\n * @returns {undefined} it's a void function\n */\n\nfunction addCssHook(element, name) {\n  if (getName(element) !== name) {\n    set(element, IS_DIRECTIVE, name);\n  }\n}\n\nexport { addCssHook };\n","/* Riot WIP, @license MIT */\nimport { defineProperties, defineDefaults, PROPS_KEY, STATE_KEY, SLOTS_KEY, ROOT_KEY } from '@riotjs/util';\nimport { COMPONENT_DOM_SELECTORS } from './component-dom-selectors.js';\nimport { COMPONENT_LIFECYCLE_METHODS } from './component-lifecycle-methods.js';\nimport cssManager from './css-manager.js';\nimport curry from 'curri';\nimport { manageComponentLifecycle } from './manage-component-lifecycle.js';\n\n/**\n * Component definition function\n * @param   {Object} implementation - the component implementation will be generated via compiler\n * @param   {Object} component - the component initial properties\n * @returns {Object} a new component implementation object\n */\n\nfunction instantiateComponent(_ref) {\n  let {\n    css,\n    template,\n    componentAPI,\n    name\n  } = _ref;\n  // add the component css into the DOM\n  if (css && name) cssManager.add(name, css);\n  return curry(manageComponentLifecycle)(defineProperties( // set the component defaults without overriding the original component API\n  defineDefaults(componentAPI, Object.assign({}, COMPONENT_LIFECYCLE_METHODS, {\n    [PROPS_KEY]: {},\n    [STATE_KEY]: {}\n  })), Object.assign({\n    // defined during the component creation\n    [SLOTS_KEY]: null,\n    [ROOT_KEY]: null\n  }, COMPONENT_DOM_SELECTORS, {\n    name,\n    css,\n    template\n  })));\n}\n\nexport { instantiateComponent };\n","/* Riot WIP, @license MIT */\nimport { IS_PURE_SYMBOL, callOrAssign, memoize } from '@riotjs/util';\nimport { MOCKED_TEMPLATE_INTERFACE } from './mocked-template-interface.js';\nimport { componentTemplateFactory } from './component-template-factory.js';\nimport { createPureComponent } from './create-pure-component.js';\nimport { instantiateComponent } from './instantiate-component.js';\n\n/**\n * Create the component interface needed for the @riotjs/dom-bindings tag bindings\n * @param   {RiotComponentWrapper} componentWrapper - riot compiler generated object\n * @param   {string} componentWrapper.css - component css\n * @param   {Function} componentWrapper.template - function that will return the dom-bindings template function\n * @param   {Object} componentWrapper.exports - component interface\n * @param   {string} componentWrapper.name - component name\n * @returns {Object} component like interface\n */\n\nfunction createComponentFromWrapper(componentWrapper) {\n  const {\n    css,\n    template,\n    exports,\n    name\n  } = componentWrapper;\n  const templateFn = template ? componentTemplateFactory(template, componentWrapper) : MOCKED_TEMPLATE_INTERFACE;\n  return _ref => {\n    let {\n      slots,\n      attributes,\n      props\n    } = _ref;\n    // pure components rendering will be managed by the end user\n    if (exports && exports[IS_PURE_SYMBOL]) return createPureComponent(exports, {\n      slots,\n      attributes,\n      props,\n      css,\n      template\n    });\n    const componentAPI = callOrAssign(exports) || {};\n    const component = instantiateComponent({\n      css,\n      template: templateFn,\n      componentAPI,\n      name\n    })({\n      slots,\n      attributes,\n      props\n    }); // notice that for the components created via tag binding\n    // we need to invert the mount (state/parentScope) arguments\n    // the template bindings will only forward the parentScope updates\n    // and never deal with the component state\n\n    return {\n      mount(element, parentScope, state) {\n        return component.mount(element, state, parentScope);\n      },\n\n      update(parentScope, state) {\n        return component.update(state, parentScope);\n      },\n\n      unmount(preserveRoot) {\n        return component.unmount(preserveRoot);\n      }\n\n    };\n  };\n}\n/**\n * Performance optimization for the recursive components\n * @param  {RiotComponentWrapper} componentWrapper - riot compiler generated object\n * @returns {Object} component like interface\n */\n\nconst memoizedCreateComponentFromWrapper = memoize(createComponentFromWrapper);\n\nexport { createComponentFromWrapper, memoizedCreateComponentFromWrapper };\n","/* Riot WIP, @license MIT */\nimport { template, expressionTypes, bindingTypes } from '@riotjs/dom-bindings';\nimport { COMPONENTS_IMPLEMENTATION_MAP } from '@riotjs/util';\nimport { createChildrenComponentsObject } from './create-children-components-object.js';\nimport { memoizedCreateComponentFromWrapper } from './create-component-from-wrapper.js';\n\n/**\n * Factory function to create the component templates only once\n * @param   {Function} template - component template creation function\n * @param   {RiotComponentWrapper} componentWrapper - riot compiler generated object\n * @returns {TemplateChunk} template chunk object\n */\n\nfunction componentTemplateFactory(template$1, componentWrapper) {\n  const components = createChildrenComponentsObject(componentWrapper.exports ? componentWrapper.exports.components : {});\n  return template$1(template, expressionTypes, bindingTypes, name => {\n    // improve support for recursive components\n    if (name === componentWrapper.name) return memoizedCreateComponentFromWrapper(componentWrapper); // return the registered components\n\n    return components[name] || COMPONENTS_IMPLEMENTATION_MAP.get(name);\n  });\n}\n\nexport { componentTemplateFactory };\n","/* Riot WIP, @license MIT */\nimport { callOrAssign, camelToDashCase } from '@riotjs/util';\nimport { createComponentFromWrapper } from './create-component-from-wrapper.js';\n\n/**\n * Create the subcomponents that can be included inside a tag in runtime\n * @param   {Object} components - components imported in runtime\n * @returns {Object} all the components transformed into Riot.Component factory functions\n */\n\nfunction createChildrenComponentsObject(components) {\n  if (components === void 0) {\n    components = {};\n  }\n\n  return Object.entries(callOrAssign(components)).reduce((acc, _ref) => {\n    let [key, value] = _ref;\n    acc[camelToDashCase(key)] = createComponentFromWrapper(value);\n    return acc;\n  }, {});\n}\n\nexport { createChildrenComponentsObject };\n","/* Riot WIP, @license MIT */\nimport { panic, defineDefaults, MOUNT_METHOD_KEY, defineProperty, IS_PURE_SYMBOL } from '@riotjs/util';\nimport { PURE_COMPONENT_API } from './pure-component-api.js';\nimport { bindDOMNodeToComponentInstance } from './bind-dom-node-to-component-instance.js';\nimport { createCoreAPIMethods } from './create-core-api-methods.js';\n\n/**\n * Create a pure component\n * @param   {Function} pureFactoryFunction - pure component factory function\n * @param   {Array} options.slots - component slots\n * @param   {Array} options.attributes - component attributes\n * @param   {Array} options.template - template factory function\n * @param   {Array} options.template - template factory function\n * @param   {any} options.props - initial component properties\n * @returns {Object} pure component object\n */\n\nfunction createPureComponent(pureFactoryFunction, _ref) {\n  let {\n    slots,\n    attributes,\n    props,\n    css,\n    template\n  } = _ref;\n  if (template) panic('Pure components can not have html');\n  if (css) panic('Pure components do not have css');\n  const component = defineDefaults(pureFactoryFunction({\n    slots,\n    attributes,\n    props\n  }), PURE_COMPONENT_API);\n  return createCoreAPIMethods(method => function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    // intercept the mount calls to bind the DOM node to the pure object created\n    // see also https://github.com/riot/riot/issues/2806\n    if (method === MOUNT_METHOD_KEY) {\n      const [element] = args; // mark this node as pure element\n\n      defineProperty(element, IS_PURE_SYMBOL, true);\n      bindDOMNodeToComponentInstance(element, component);\n    }\n\n    component[method](...args);\n    return component;\n  });\n}\n\nexport { createPureComponent };\n","/* Riot WIP, @license MIT */\nimport $ from 'bianco.query';\nimport { set } from 'bianco.attr';\n\nconst CSS_BY_NAME = new Map();\nconst STYLE_NODE_SELECTOR = 'style[riot]'; // memoized curried function\n\nconst getStyleNode = (style => {\n  return () => {\n    // lazy evaluation:\n    // if this function was already called before\n    // we return its cached result\n    if (style) return style; // create a new style element or use an existing one\n    // and cache it internally\n\n    style = $(STYLE_NODE_SELECTOR)[0] || document.createElement('style');\n    set(style, 'type', 'text/css');\n    /* istanbul ignore next */\n\n    if (!style.parentNode) document.head.appendChild(style);\n    return style;\n  };\n})();\n/**\n * Object that will be used to inject and manage the css of every tag instance\n */\n\n\nconst cssManager = {\n  CSS_BY_NAME,\n\n  /**\n   * Save a tag style to be later injected into DOM\n   * @param { string } name - if it's passed we will map the css to a tagname\n   * @param { string } css - css string\n   * @returns {Object} self\n   */\n  add(name, css) {\n    if (!CSS_BY_NAME.has(name)) {\n      CSS_BY_NAME.set(name, css);\n      this.inject();\n    }\n\n    return this;\n  },\n\n  /**\n   * Inject all previously saved tag styles into DOM\n   * innerHTML seems slow: http://jsperf.com/riot-insert-style\n   * @returns {Object} self\n   */\n  inject() {\n    getStyleNode().innerHTML = [...CSS_BY_NAME.values()].join('\\n');\n    return this;\n  },\n\n  /**\n   * Remove a tag style from the DOM\n   * @param {string} name a registered tagname\n   * @returns {Object} self\n   */\n  remove(name) {\n    if (CSS_BY_NAME.has(name)) {\n      CSS_BY_NAME.delete(name);\n      this.inject();\n    }\n\n    return this;\n  }\n\n};\n\nexport { CSS_BY_NAME, STYLE_NODE_SELECTOR, cssManager as default };\n","/* Riot WIP, @license MIT */\nimport { COMPONENTS_IMPLEMENTATION_MAP, panic } from '@riotjs/util';\nimport cssManager from '../core/css-manager.js';\n\n/**\n * Unregister a riot web component\n * @param   {string} name - component name\n * @returns {Map} map containing all the components implementations\n */\n\nfunction unregister(name) {\n  if (!COMPONENTS_IMPLEMENTATION_MAP.has(name)) panic(`The component \"${name}\" was never registered`);\n  COMPONENTS_IMPLEMENTATION_MAP.delete(name);\n  cssManager.remove(name);\n  return COMPONENTS_IMPLEMENTATION_MAP;\n}\n\nexport { unregister };\n","/* Riot WIP, @license MIT */\nimport $ from 'bianco.query';\nimport { mountComponent } from '../core/mount-component.js';\n\n/**\n * Mounting function that will work only for the components that were globally registered\n * @param   {string|HTMLElement} selector - query for the selection or a DOM element\n * @param   {Object} initialProps - the initial component properties\n * @param   {string} name - optional component name\n * @returns {Array} list of riot components\n */\n\nfunction mount(selector, initialProps, name) {\n  return $(selector).map(element => mountComponent(element, initialProps, name));\n}\n\nexport { mount };\n","/* Riot WIP, @license MIT */\nimport { COMPONENTS_IMPLEMENTATION_MAP, panic } from '@riotjs/util';\nimport { getName } from '../utils/dom.js';\n\n/**\n * Component initialization function starting from a DOM node\n * @param   {HTMLElement} element - element to upgrade\n * @param   {Object} initialProps - initial component properties\n * @param   {string} componentName - component id\n * @param   {Array} slots - component slots\n * @returns {Object} a new component instance bound to a DOM node\n */\n\nfunction mountComponent(element, initialProps, componentName, slots) {\n  const name = componentName || getName(element);\n  if (!COMPONENTS_IMPLEMENTATION_MAP.has(name)) panic(`The component named \"${name}\" was never registered`);\n  const component = COMPONENTS_IMPLEMENTATION_MAP.get(name)({\n    props: initialProps,\n    slots\n  });\n  return component.mount(element);\n}\n\nexport { mountComponent };\n","/* Riot WIP, @license MIT */\nimport $ from 'bianco.query';\nimport { DOM_COMPONENT_INSTANCE_PROPERTY } from '@riotjs/util';\n\n/**\n * Sweet unmounting helper function for the DOM node mounted manually by the user\n * @param   {string|HTMLElement} selector - query for the selection or a DOM element\n * @param   {boolean|null} keepRootElement - if true keep the root element\n * @returns {Array} list of nodes unmounted\n */\n\nfunction unmount(selector, keepRootElement) {\n  return $(selector).map(element => {\n    if (element[DOM_COMPONENT_INSTANCE_PROPERTY]) {\n      element[DOM_COMPONENT_INSTANCE_PROPERTY].unmount(keepRootElement);\n    }\n\n    return element;\n  });\n}\n\nexport { unmount };\n","/* Riot WIP, @license MIT */\nimport { isFunction, panic, PLUGINS_SET } from '@riotjs/util';\n\n/**\n * Define a riot plugin\n * @param   {Function} plugin - function that will receive all the components created\n * @returns {Set} the set containing all the plugins installed\n */\n\nfunction install(plugin) {\n  if (!isFunction(plugin)) panic('Plugins must be of type function');\n  if (PLUGINS_SET.has(plugin)) panic('This plugin was already installed');\n  PLUGINS_SET.add(plugin);\n  return PLUGINS_SET;\n}\n\nexport { install };\n","/* Riot WIP, @license MIT */\nimport { PLUGINS_SET, panic } from '@riotjs/util';\n\n/**\n * Uninstall a riot plugin\n * @param   {Function} plugin - plugin previously installed\n * @returns {Set} the set containing all the plugins installed\n */\n\nfunction uninstall(plugin) {\n  if (!PLUGINS_SET.has(plugin)) panic('This plugin was never installed');\n  PLUGINS_SET.delete(plugin);\n  return PLUGINS_SET;\n}\n\nexport { uninstall };\n","/* Riot WIP, @license MIT */\n/**\n * no-op function needed to add the proper types to your component via typescript\n * @param {Function|Object} component - component default export\n * @returns {Function|Object} returns exactly what it has received\n */\n\n/* istanbul ignore next */\nconst withTypes = component => component;\n\nexport { withTypes };\n","/* Riot WIP, @license MIT */\n/** @type {string} current riot version */\nconst version = 'WIP';\n\nexport { version };\n","/* Riot WIP, @license MIT */\nimport { IS_DIRECTIVE } from '@riotjs/util';\nimport { get } from 'bianco.attr';\n\n/**\n * Get the tag name of any DOM node\n * @param   {HTMLElement} element - DOM node we want to inspect\n * @returns {string} name to identify this dom node in riot\n */\n\nfunction getName(element) {\n  return get(element, IS_DIRECTIVE) || element.tagName.toLowerCase();\n}\n\nexport { getName };\n","var map = {\n\t\"./footer/my-footer.riot\": 757,\n\t\"./header/my-header.riot\": 643\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 329;","import { register } from \"riot\";\n\nconst basename = (path, extension = \"\") =>\n  path.split(\"/\").reverse()[0].replace(extension, \"\");\nconst globalComponentsContext = require.context(\n  \"./components/global/\",\n  true,\n  /[a-zA-Z0-9-]+\\.riot/,\n);\n\nexport default () => {\n  globalComponentsContext.keys().map((path) => {\n    const name = basename(path, \".riot\");\n\n    const component = globalComponentsContext(path);\n\n    register(name, component.default || component);\n\n    return {\n      name,\n      component,\n    };\n  });\n};\n","import \"@riotjs/hot-reload\";\nimport { component } from \"riot\";\n// import { registerPreprocessor } from \"@riotjs/compiler\";\n// import sass from \"sass\";\nimport App from \"./app.riot\";\nimport registerGlobalComponents from \"./register-global-components\";\n\n// register preprocessor\n// registerPreprocessor(\"css\", \"sass\", function (code, { options }) {\n//   const { file } = options;\n//   console.log(\"Compile the sass code in\", file);\n\n//   return {\n//     code: sass.compileString(code, { syntax: \"indented\" }).css,\n//     map: null,\n//   };\n// });\n\n// register\nregisterGlobalComponents();\n\n// mount the root tag\ncomponent(App)(document.getElementById(\"root\") || document.body);\n","export default [\n  {\n    path: \"/\",\n    label: \"Home\",\n    componentName: \"home\",\n    initialProps: {},\n  },\n  {\n    path: \"/about\",\n    label: \"About\",\n    componentName: \"about\",\n    initialProps: {\n      count: 0,\n    },\n  },\n];\n","module.exports = url;","__webpack_require__.O(0, [143], function() {\n\t__webpack_require__.E(229);\n\t__webpack_require__.E(521);\n}, 5);"],"names":["HEAD_SYMBOL","Symbol","TAIL_SYMBOL","UNMOUNT_SCOPE","EachBinding","nodes","mount","scope","parentScope","this","update","placeholder","childrenMap","collection","evaluate","items","Array","from","newChildrenMap","batches","futureNodes","binding","condition","template","itemName","getKey","indexName","root","isTemplateTag","Map","forEach","item","index","context","extendScope","Object","create","key","oldItem","get","mustFilterItem","mustMount","componentTemplate","clone","el","cloneNode","meta","fragment","dom","head","tail","document","createTextNode","createHeadTailPlaceholders","avoidDOMInjection","children","childNodes","createTemplateMeta","push","delete","set","createPatch","a","b","before","bLength","length","aEnd","bEnd","aStart","bStart","map","node","has","nextSibling","i","sequence","udomdiff","redundant","info","element","pop","unmount","patch","values","fn","IfBinding","value","mustUnmount","pristine","ElementProto","Element","prototype","isNativeHtmlProperty","name","hasOwnProperty","RE_EVENTS_PREFIX","EventListener","handleEvent","event","type","ListenersWeakMap","WeakMap","normalizeStringValue","getTextNode","childNodeIndex","target","nodeType","Node","COMMENT_NODE","textNode","replaceChild","attributeExpression","oldValue","newAttributes","oldAttributes","newKeys","keys","filter","includes","attribute","removeAttribute","removeAllAttributes","attributes","entries","setAllAttributes","shouldRemoveAttribute","canRenderAttribute","setAttribute","normalizeValue","normalizedEventName","replace","eventListener","listener","createListener","callback","options","isArray","getCallbackAndOptions","handler","mustAddEvent","removeEventListener","addEventListener","data","expression","Expression","apply","expressions","getRealParent","SlotBinding","getTemplateScope","attr","assign","extendParentScope","templateData","slots","find","id","parentNode","realParent","html","bindings","createDOM","moveSlotInnerContent","mustRemoveRoot","slot","child","firstChild","slotBindings","reduce","acc","concat","TagBinding","tag","component","slotsToMarkup","getTag","getComponent","keepRootTag","IF","methods","method","fixTextExpressionsOffset","textExpressionsOffset","e","templateTagOffset","selector","redundantAttribute","querySelector","bindingExpressions","TemplateChunk","container","ownerDocument","importNode","window","DOMParser","parseFromString","documentElement","createSVGTree","createElement","innerHTML","content","createHTMLTree","createDOMTree","createTemplateDOM","createDocumentFragment","siblings","Math","max","indexOf","getTemplateTagOffset","appendChild","injectDOM","bindingsData","exports","riot","$","_interopDefaultLegacy","$__default","cssManager","__","DOM_COMPONENT_INSTANCE_PROPERTY","globals","reload","componentAPI","oldTag","remove","newTag","props","state","console","warn","defineProperty","factory","cache","lazy","Loader","Component","export","hasLoader","LazyComponent","cachedComponent","isMounted","mountLazyComponent","dispatchEvent","Event","createManagedComponent","Promise","resolve","then","default","Child","args","escapeString","str","flags","sensitive","stringToRegexp","path","tokens","_a","strict","_b","start","_c","end","_d","encode","x","endsWith","delimiter","route","_i","tokens_1","token","prefix","suffix","pattern","modifier","mod","endToken","isEndDelimited","undefined","RegExp","tokensToRegexp","char","count","j","TypeError","code","charCodeAt","lexer","prefixes","defaultPattern","result","tryConsume","mustConsume","nextType","consumeText","name_1","pattern_1","parse","pathToRegexp","groupsRegex","execResult","exec","source","regexpToRegexp","paths","parts","join","arrayToRegexp","CANCEL","ruit","_len2","arguments","tasks","_key2","reject","run","queue","task","rest","done","v","cancel","compose","_len","_key","reverse","API_METHODS","Set","UNSUBSCRIBE_SYMBOL","createStream","modifiers","stream","input","next","dispatch","callbacks","f","panic$2","message","Error","erre","fns","success","error","generator","addToCollection","add","deleteFromCollection","on","freeze","off","connect","res","err","return","clear","fork","install","isNode","process","replaceBase","defaults","base","matchOrSkip","pathRegExp","match","panic$1","silentErrors","router","isString","mergeOptions","toRegexp","test","createURLStreamPipe","decodeURI","params","url","URL","parseURL","param","decodeURIComponent","toURL","createRoute","URLStream","dispatcherStream","receiverStream","getCurrentRoute","currentRoute","r","getInitialRouteValue","g","routeHoc","css","onBeforeMount","onBeforeRoute","onRoute","callLifecycleProperty","onUnmounted","expressionTypes","bindingTypes","_scope","SLOT","ATTRIBUTE","getGlobal","getWindow","getDocument","getLocation","win","location","defer","globalScope","requestAnimationFrame","setTimeout","cancelDefer","cancelAnimationFrame","clearTimeout","WINDOW_EVENTS","CLICK_EVENT","SLASH","RE_ORIGIN","removeTrailingSlash","substr","domToArray","els","toString","call","manageEvents","evList","cb","l","split","normalize","names","n","parseNodes","onWindowEvent","normalizePath","String","href","onRouterPush","loc","hist","history","doc","pushState","title","getLinkElement","isLinkNode","nodeName","onClick","which","metaKey","ctrlKey","shiftKey","defaultPrevented","isEventForbidden","isTargetSelfLink","isForbiddenLink","isHashLink","isInBase","preventDefault","BASE_ATTRIBUTE_NAME","wasInitialized","routerHoc","panic","getAttribute","_","c","toUpperCase","teardown","initialRouteAttr","initialRoute","onFirstRoute","createSlot","initDomListeners","setBase","onStartedAttr","deferred","getBase","baseAttr","protocol","host","pathname","Boolean","normalizeBase","EACH","SIMPLE","TAG","checkType","isSvg","owner","ownerSVGElement","isTemplate","tagName","toLowerCase","isFunction","isBoolean","isObject","isNil","constructor","COMPONENTS_IMPLEMENTATION_MAP","PLUGINS_SET","IS_DIRECTIVE","MOUNT_METHOD_KEY","UPDATE_METHOD_KEY","UNMOUNT_METHOD_KEY","SHOULD_UPDATE_KEY","ON_BEFORE_MOUNT_KEY","ON_MOUNTED_KEY","ON_BEFORE_UPDATE_KEY","ON_UPDATED_KEY","ON_BEFORE_UNMOUNT_KEY","ON_UNMOUNTED_KEY","PROPS_KEY","STATE_KEY","SLOTS_KEY","ROOT_KEY","IS_PURE_SYMBOL","IS_COMPONENT_UPDATING","PARENT_KEY_SYMBOL","ATTRIBUTES_KEY_SYMBOL","TEMPLATE_KEY_SYMBOL","DOMattributesToObject","moveChildren","cleanNode","clearChildren","removeChild","insertBefore","newNode","refNode","replaced","EVENT","TEXT","VALUE","noop","autobindMethods","bind","callOrAssign","memoize","cached","val","evaluateAttributeExpressions","enumerable","writable","configurable","defineProperties","properties","defineDefaults","camelToDashCase","string","dashToCamelCase","components","Router","Route","NotFound","MyHeader","MyFooter","Home","About","pages","showNotFound","activePage","isServer","anyRouteStream","onAnyRoute","p","onBeforeUnmount","page","label","componentName","initialProps","textDecoration","attrs","prop","querySelectorAll","DOMBindings","createBinding","createExpression","implementation","_temp","pure","func","register","_ref","PURE_COMPONENT_API","MOCKED_TEMPLATE_INTERFACE","bindDOMNodeToComponentInstance","createCoreAPIMethods","mapFunction","COMPONENT_DOM_SELECTORS","$$","COMPONENT_LIFECYCLE_METHODS","curry","computeComponentState","oldState","newState","manageComponentLifecycle","runPlugins","createAttributeBindings","computeInitialProps","addCssHook","newProps","preserveRoot","instantiateComponent","createComponentFromWrapper","componentWrapper","templateFn","template$1","createChildrenComponentsObject","memoizedCreateComponentFromWrapper","componentTemplateFactory","pureFactoryFunction","createPureComponent","CSS_BY_NAME","style","inject","unregister","mountComponent","keepRootElement","plugin","uninstall","withTypes","version","getName","webpackContext","req","webpackContextResolve","__webpack_require__","o","module","globalComponentsContext","extension","basename","getElementById","body","O","E"],"sourceRoot":""}